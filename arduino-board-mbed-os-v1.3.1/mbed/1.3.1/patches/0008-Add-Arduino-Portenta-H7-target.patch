From f047a7a75560af5465fd79bcb12de5455efc8eaf Mon Sep 17 00:00:00 2001
From: Martino Facchin <m.facchin@arduino.cc>
Date: Fri, 9 Aug 2019 16:29:30 +0200
Subject: [PATCH 08/31] Add Arduino Portenta H7 target

Add some defines for Envie

Change Envie base clock

Add QSPI support

Add Envie support

Fix some pinmux

Add ENVIE folder in TARGET_WICED

Add ethernet support

Partially port Envie to mainline

Add USBDEVICE support to H747

Declare USB pins for Envie

[ENVIE] Add pin definitions

Envie: restore HSEM irq handlers

ENVIE: enable setting an app offset

Envie: make Ethernet support mainlineable

Envie: ETH: set GPIo speed as very high

ENVIE: fix power tree

Envie: use complete pin_peripheral from ST

Envie: Adjust PLL

EnvieM4: fix available RAM

Envie: fix OTG USB functionality

Envie: remove fake arduino pins

ENVIE: fix build after removing Arduino pins

Envie: fix analog pinmux

Envie: force using external crystal

Enable oscillator at startup

Envie: Fix clock

EnvieM4: move OpenAMP defines to library

Envie: M4: eth: don't try to disable nonexisting caches

Envie: Cordio: restore functionality

Portenta: ETH: reset phy and add sw pinstrap

Envie: fix MCU name and remove SERIAL_ASYNC

Portenta: ethernet: set pinstrap to autonegoziation, 100Mbit

Portenta: fix HSI PLL multiplier

Portenta: use PWR_SMPS_1V8_SUPPLIES_LDO power scheme

Envie: delay oscillator start for Abracom

added initialization for HSICalibrationValue to prevent random clock setting

Added mbed original LED naming
---
 components/wifi/esp8266-driver/mbed_lib.json  |   4 +
 .../TARGET_STM/TARGET_CYW4343X/HCIDriver.cpp  | 465 +++++++++++
 .../TARGET_PORTENTA_H7/stm32h7_eth_init.c     | 170 ++++
 .../emac-drivers/TARGET_STM/stm32xx_emac.cpp  |   2 +
 .../TARGET_PORTENTA_H7/PeripheralNames.h      | 106 +++
 .../TARGET_PORTENTA_H7/PeripheralPins.c       | 599 +++++++++++++
 .../TARGET_PORTENTA_H7/PinNames.h             | 448 ++++++++++
 .../TARGET_PORTENTA_H7/system_clock.c         | 227 +++++
 .../TARGET_PORTENTA_H7/system_stm32h7xx.c     | 390 +++++++++
 .../TOOLCHAIN_GCC_ARM/STM32H747xI.ld          | 202 +++++
 .../TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S   | 787 ++++++++++++++++++
 .../TOOLCHAIN_GCC_ARM/STM32H747xI.ld          | 220 +++++
 .../TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S   | 787 ++++++++++++++++++
 targets/TARGET_STM/TARGET_STM32H7/objects.h   |   1 +
 targets/TARGET_STM/USBPhy_STM32.cpp           |   4 +
 targets/targets.json                          |  92 ++
 16 files changed, 4504 insertions(+)
 create mode 100644 features/FEATURE_BLE/targets/TARGET_STM/TARGET_CYW4343X/HCIDriver.cpp
 create mode 100644 features/netsocket/emac-drivers/TARGET_STM/TARGET_STM32H7/TARGET_PORTENTA_H7/stm32h7_eth_init.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralNames.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralPins.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PinNames.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_clock.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_stm32h7xx.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/STM32H747xI.ld
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/STM32H747xI.ld
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S

diff --git a/components/wifi/esp8266-driver/mbed_lib.json b/components/wifi/esp8266-driver/mbed_lib.json
index 6eefffc00f..c65c7a63f4 100644
--- a/components/wifi/esp8266-driver/mbed_lib.json
+++ b/components/wifi/esp8266-driver/mbed_lib.json
@@ -103,6 +103,10 @@
         "NUCLEO_F411RE": {
             "tx": "D8",
             "rx": "D2"
+        },
+        "PORTENTA_H7": {
+            "tx": "PA_9",
+            "rx": "PA_10"
         }
     }
 }
diff --git a/features/FEATURE_BLE/targets/TARGET_STM/TARGET_CYW4343X/HCIDriver.cpp b/features/FEATURE_BLE/targets/TARGET_STM/TARGET_CYW4343X/HCIDriver.cpp
new file mode 100644
index 0000000000..dc6062a216
--- /dev/null
+++ b/features/FEATURE_BLE/targets/TARGET_STM/TARGET_CYW4343X/HCIDriver.cpp
@@ -0,0 +1,465 @@
+/*
+ * Copyright (c) 2018 ARM Limited
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include "CordioBLE.h"
+#include "CordioHCIDriver.h"
+#include "hci_api.h"
+#include "hci_cmd.h"
+#include "hci_core.h"
+#include "bstream.h"
+#include <stdbool.h>
+#include "hci_mbed_os_adaptation.h"
+#include "H4TransportDriver.h"
+
+extern const int brcm_patch_ram_length;
+extern const uint8_t brcm_patchram_buf[];
+
+static const uint8_t pre_brcm_patchram_buf[] = {
+    // RESET followed by download mini driver cmd
+    0x03, 0x0C, 0x00,
+    0x2E, 0xFC, 0x00,
+};
+static const int pre_brcm_patch_ram_length = sizeof(pre_brcm_patchram_buf);
+
+#define HCI_RESET_RAND_CNT        4
+#define HCI_VS_CMD_SET_SLEEP_MODE 0xFC27
+
+
+extern "C" uint32_t Set_GPIO_Clock(uint32_t port_idx);
+
+// 0: push pull
+// 1: open drain
+static void output_mode(PinName pin, int mode)
+{
+    MBED_ASSERT(pin != (PinName)NC);
+    uint32_t port_index = STM_PORT(pin);
+    uint32_t pin_index  = STM_PIN(pin);
+
+    // Enable GPIO clock
+    uint32_t gpio_add = Set_GPIO_Clock(port_index);
+    GPIO_TypeDef *gpio = (GPIO_TypeDef *)gpio_add;
+
+#if defined(STM32H7)
+    #define GPIO_OTYPER_OT_0 GPIO_OTYPER_OT0
+#endif
+
+    /* Output mode configuration*/
+    gpio->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pin_index)) ;
+    gpio->OTYPER |= (uint16_t)(((uint16_t)mode) << ((uint16_t)pin_index));
+}
+
+namespace ble {
+namespace vendor {
+namespace wise1530 {
+
+class HCIDriver : public cordio::CordioHCIDriver {
+public:
+    HCIDriver(
+        cordio::CordioHCITransportDriver& transport_driver,
+        PinName bt_host_wake_name,
+        PinName bt_device_wake_name,
+        PinName bt_power_name
+    ) : cordio::CordioHCIDriver(transport_driver),
+        bt_host_wake_name(bt_host_wake_name),
+        bt_device_wake_name(bt_device_wake_name),
+        bt_power_name(bt_power_name),
+        bt_host_wake(bt_host_wake_name, PIN_INPUT, PullNone, 0),
+        bt_device_wake(bt_device_wake_name, PIN_OUTPUT, PullDefault, 1),
+        bt_power(bt_power_name, PIN_OUTPUT, PullUp, 0),
+        service_pack_index(0),
+        service_pack_ptr(0),
+        service_pack_length(0),
+        service_pack_next(),
+        service_pack_transfered(false) {
+    }
+
+    virtual cordio::buf_pool_desc_t get_buffer_pool_description()
+    {
+        // Use default buffer pool
+        return cordio::CordioHCIDriver::get_default_buffer_pool_description();
+    }
+
+    virtual void do_initialize()
+    {
+        output_mode(bt_host_wake_name, 1);
+        output_mode(bt_device_wake_name, 0);
+        output_mode(bt_power_name, 1);
+
+        ThisThread::sleep_for(500);
+
+        bt_device_wake = 0;
+        ThisThread::sleep_for(500);
+
+        bt_power = 1;
+        ThisThread::sleep_for(500);
+    }
+
+    virtual void do_terminate() { }
+
+    virtual void start_reset_sequence()
+    {
+        prepare_service_pack_transfert();
+    }
+
+    virtual void handle_reset_sequence(uint8_t *pMsg)
+    {
+        uint16_t       opcode;
+        static uint8_t randCnt;
+
+        /* if event is a command complete event */
+        if (*pMsg == HCI_CMD_CMPL_EVT) {
+            /* parse parameters */
+            pMsg += HCI_EVT_HDR_LEN;
+            pMsg++;                   /* skip num packets */
+            BSTREAM_TO_UINT16(opcode, pMsg);
+            pMsg++;                   /* skip status */
+
+            if (service_pack_transfered == false) {
+                randCnt = 0;
+                ack_service_pack_command(opcode, pMsg);
+                return;
+            }
+
+            /* decode opcode */
+            switch (opcode) {
+                // Note: Reset is handled by ack_service_pack.
+                case HCI_VS_CMD_SET_SLEEP_MODE:
+                    HciWriteLeHostSupport();
+                    break;
+
+                case HCI_OPCODE_WRITE_LE_HOST_SUPPORT:
+                    randCnt = 0;
+                    /* send next command in sequence */
+                    HciSetEventMaskCmd((uint8_t *) hciEventMask);
+                    break;
+
+                case HCI_OPCODE_SET_EVENT_MASK:
+                    randCnt = 0;
+                    /* send next command in sequence */
+                    HciLeSetEventMaskCmd((uint8_t *) hciLeEventMask);
+                    break;
+
+                case HCI_OPCODE_LE_SET_EVENT_MASK:
+                    /* send next command in sequence */
+                    HciSetEventMaskPage2Cmd((uint8_t *) hciEventMaskPage2);
+                    break;
+
+                case HCI_OPCODE_SET_EVENT_MASK_PAGE2:
+                    /* send next command in sequence */
+                    HciReadBdAddrCmd();
+                    break;
+
+                case HCI_OPCODE_READ_BD_ADDR:
+                    /* parse and store event parameters */
+                    BdaCpy(hciCoreCb.bdAddr, pMsg);
+                    HciLeReadBufSizeCmd();
+                    break;
+
+                case HCI_OPCODE_LE_READ_BUF_SIZE:
+                    /* parse and store event parameters */
+                    BSTREAM_TO_UINT16(hciCoreCb.bufSize, pMsg);
+                    BSTREAM_TO_UINT8(hciCoreCb.numBufs, pMsg);
+
+                    // FixMe: The number of ACL buffer returned by the chip is
+                    // incorrect. If more than two ACL packets are present in
+                    // the controller, it may block the controller.
+                    // Important: The ACL overflow event is **not** reported
+                    // by the controller.
+                    hciCoreCb.numBufs = 2;
+
+                    /* initialize ACL buffer accounting */
+                    hciCoreCb.availBufs = hciCoreCb.numBufs;
+
+                    /* send next command in sequence */
+                    HciLeReadSupStatesCmd();
+                    break;
+
+                case HCI_OPCODE_LE_READ_SUP_STATES:
+                    /* parse and store event parameters */
+                    memcpy(hciCoreCb.leStates, pMsg, HCI_LE_STATES_LEN);
+
+                    /* send next command in sequence */
+                    HciLeReadWhiteListSizeCmd();
+                    break;
+
+                case HCI_OPCODE_LE_READ_WHITE_LIST_SIZE:
+                    /* parse and store event parameters */
+                    BSTREAM_TO_UINT8(hciCoreCb.whiteListSize, pMsg);
+
+                    /* send next command in sequence */
+                    HciLeReadLocalSupFeatCmd();
+                    break;
+
+                case HCI_OPCODE_LE_READ_LOCAL_SUP_FEAT:
+                    /* parse and store event parameters */
+                    BSTREAM_TO_UINT16(hciCoreCb.leSupFeat, pMsg);
+
+                    /* send next command in sequence */
+                    hciCoreReadResolvingListSize();
+                    break;
+
+                case HCI_OPCODE_LE_READ_RES_LIST_SIZE:
+                    /* parse and store event parameters */
+                    BSTREAM_TO_UINT8(hciCoreCb.resListSize, pMsg);
+
+                    /* send next command in sequence */
+                    hciCoreReadMaxDataLen();
+                    break;
+
+                case HCI_OPCODE_LE_READ_MAX_DATA_LEN: {
+                    uint16_t maxTxOctets;
+                    uint16_t maxTxTime;
+
+                    BSTREAM_TO_UINT16(maxTxOctets, pMsg);
+                    BSTREAM_TO_UINT16(maxTxTime, pMsg);
+
+                    /* use Controller's maximum supported payload octets and packet duration times
+                    * for transmission as Host's suggested values for maximum transmission number
+                    * of payload octets and maximum packet transmission time for new connections.
+                    */
+                    HciLeWriteDefDataLen(maxTxOctets, maxTxTime);
+                }   break;
+
+                case HCI_OPCODE_LE_WRITE_DEF_DATA_LEN:
+                    if (hciCoreCb.extResetSeq) {
+                        /* send first extended command */
+                        (*hciCoreCb.extResetSeq)(pMsg, opcode);
+                    } else {
+                        /* initialize extended parameters */
+                        hciCoreCb.maxAdvDataLen = 0;
+                        hciCoreCb.numSupAdvSets = 0;
+                        hciCoreCb.perAdvListSize = 0;
+
+                        /* send next command in sequence */
+                        HciLeRandCmd();
+                    }
+                    break;
+
+                case HCI_OPCODE_LE_READ_MAX_ADV_DATA_LEN:
+                case HCI_OPCODE_LE_READ_NUM_SUP_ADV_SETS:
+                case HCI_OPCODE_LE_READ_PER_ADV_LIST_SIZE:
+                    if (hciCoreCb.extResetSeq) {
+                        /* send next extended command in sequence */
+                        (*hciCoreCb.extResetSeq)(pMsg, opcode);
+                    }
+                    break;
+
+                case HCI_OPCODE_LE_RAND:
+                    /* check if need to send second rand command */
+                    if (randCnt < (HCI_RESET_RAND_CNT-1)) {
+                        randCnt++;
+                        HciLeRandCmd();
+                    } else {
+                        uint8_t addr[6] = { 0 };
+                        memcpy(addr, pMsg, sizeof(addr));
+                        DM_RAND_ADDR_SET(addr, DM_RAND_ADDR_STATIC);
+                        // note: will invoke set rand address
+                        set_random_static_address(addr);
+                    }
+                    break;
+
+                case HCI_OPCODE_LE_SET_RAND_ADDR:
+                    /* send next command in sequence */
+                    signal_reset_sequence_done();
+                    break;
+
+                default:
+                    break;
+            }
+        }
+    }
+
+private:
+
+    // send pre_brcm_patchram_buf
+    void prepare_service_pack_transfert(void)
+    {
+        service_pack_ptr = pre_brcm_patchram_buf;
+        service_pack_length = pre_brcm_patch_ram_length;
+        service_pack_next = &HCIDriver::start_service_pack_transfert;
+        service_pack_index = 0;
+        service_pack_transfered = false;
+        send_service_pack_command();
+    }
+
+    // Called once pre_brcm_patchram_buf has been transferred; send brcm_patchram_buf
+    void start_service_pack_transfert(void)
+    {
+        service_pack_ptr = brcm_patchram_buf;
+        service_pack_length = brcm_patch_ram_length;
+        service_pack_next = &HCIDriver::terminate_service_pack_transfert;
+        service_pack_index = 0;
+        service_pack_transfered = false;
+        send_service_pack_command();
+    }
+
+    // Called once post_brcm_patchram_buf has been transferred; start regular initialization.
+    void terminate_service_pack_transfert(void)
+    {
+        service_pack_ptr = NULL;
+        service_pack_length = 0;
+        service_pack_next = NULL;
+        service_pack_index = 0;
+        service_pack_transfered = true;
+        ThisThread::sleep_for(1000);
+        set_sleep_mode();
+    }
+
+    void send_service_pack_command(void)
+    {
+        uint16_t cmd_len = service_pack_ptr[service_pack_index + 2];
+        uint16_t cmd_opcode = (service_pack_ptr[service_pack_index + 1] << 8) | service_pack_ptr[service_pack_index + 0];
+        uint8_t *pBuf = hciCmdAlloc(cmd_opcode, cmd_len);
+        if (pBuf) {
+            memcpy(pBuf + HCI_CMD_HDR_LEN, service_pack_ptr + service_pack_index + HCI_CMD_HDR_LEN, cmd_len);
+            hciCmdSend(pBuf);
+        } else {
+        }
+    }
+
+    void ack_service_pack_command(uint16_t opcode, uint8_t* msg)
+    {
+        uint16_t cmd_opcode = (service_pack_ptr[service_pack_index + 1] << 8) | service_pack_ptr[service_pack_index + 0];
+
+        if (cmd_opcode != opcode)  {
+            // DO something in case of error
+
+            while (true);
+
+        }
+
+        // update service pack index
+        service_pack_index += (HCI_CMD_HDR_LEN + service_pack_ptr[service_pack_index + 2]);
+
+        if (service_pack_index < service_pack_length) {
+            send_service_pack_command();
+        } else {
+            (this->*service_pack_next)();
+        }
+    }
+
+    void set_sleep_mode()
+    {
+            uint8_t *pBuf;
+            if ((pBuf = hciCmdAlloc(HCI_VS_CMD_SET_SLEEP_MODE, 12)) != NULL)
+            {
+                  pBuf[HCI_CMD_HDR_LEN] = 0x00; // no sleep moode
+                  pBuf[HCI_CMD_HDR_LEN + 1] = 0x00; // no idle threshold host (N/A)
+                  pBuf[HCI_CMD_HDR_LEN + 2] = 0x00; // no idle threshold HC (N/A)
+                  pBuf[HCI_CMD_HDR_LEN + 3] = 0x00; // BT WAKE
+                  pBuf[HCI_CMD_HDR_LEN + 4] = 0x00; // HOST WAKE
+                  pBuf[HCI_CMD_HDR_LEN + 5] = 0x00; // Sleep during SCO
+                  pBuf[HCI_CMD_HDR_LEN + 6] = 0x00; // Combining sleep mode and SCM
+                  pBuf[HCI_CMD_HDR_LEN + 7] = 0x00; // Tristate TX
+                  pBuf[HCI_CMD_HDR_LEN + 8] = 0x00; // Active connection handling on suspend
+                  pBuf[HCI_CMD_HDR_LEN + 9] = 0x00; // resume timeout
+                  pBuf[HCI_CMD_HDR_LEN + 10] = 0x00; // break to host
+                  pBuf[HCI_CMD_HDR_LEN + 10] = 0x00; // Pulsed host wake
+                  hciCmdSend(pBuf);
+            }
+    }
+
+    static const uint16_t HCI_OPCODE_WRITE_LE_HOST_SUPPORT = 0x0C6D;
+
+    void HciWriteLeHostSupport()
+    {
+      uint8_t *pBuf;
+      if ((pBuf = hciCmdAlloc(HCI_OPCODE_WRITE_LE_HOST_SUPPORT, 2)) != NULL)
+      {
+        pBuf[HCI_CMD_HDR_LEN] = 0x01;
+        pBuf[HCI_CMD_HDR_LEN + 1] = 0x00;
+        hciCmdSend(pBuf);
+      }
+    }
+
+    void hciCoreReadResolvingListSize(void)
+    {
+        /* if LL Privacy is supported by Controller and included */
+        if ((hciCoreCb.leSupFeat & HCI_LE_SUP_FEAT_PRIVACY) &&
+            (hciLeSupFeatCfg & HCI_LE_SUP_FEAT_PRIVACY))
+        {
+            /* send next command in sequence */
+            HciLeReadResolvingListSize();
+        }
+        else
+        {
+            hciCoreCb.resListSize = 0;
+
+            /* send next command in sequence */
+            hciCoreReadMaxDataLen();
+        }
+    }
+
+    void hciCoreReadMaxDataLen(void)
+    {
+    /* if LE Data Packet Length Extensions is supported by Controller and included */
+        if ((hciCoreCb.leSupFeat & HCI_LE_SUP_FEAT_DATA_LEN_EXT) &&
+            (hciLeSupFeatCfg & HCI_LE_SUP_FEAT_DATA_LEN_EXT))
+        {
+            /* send next command in sequence */
+            HciLeReadMaxDataLen();
+        }
+        else
+        {
+            /* send next command in sequence */
+            HciLeRandCmd();
+        }
+    }
+
+    PinName bt_host_wake_name;
+    PinName bt_device_wake_name;
+    PinName bt_power_name;
+    DigitalInOut bt_host_wake;
+    DigitalInOut bt_device_wake;
+    DigitalInOut bt_power;
+    size_t service_pack_index;
+    const uint8_t* service_pack_ptr;
+    int service_pack_length;
+    void (HCIDriver::*service_pack_next)();
+    bool service_pack_transfered;
+
+};
+
+} // namespace wise1530
+} // namespace vendor
+} // namespace ble
+
+#if defined(STM32H7)
+
+ble::vendor::cordio::CordioHCIDriver& ble_cordio_get_hci_driver() {
+    static ble::vendor::cordio::H4TransportDriver transport_driver(
+        /* TX */ PA_15, /* RX */ PF_6, /* cts */ PF_9, /* rts */ PF_8, 115200
+    );
+    static ble::vendor::wise1530::HCIDriver hci_driver(
+        transport_driver, /* host wake */ PJ_13, /* device wake */ PJ_14, /* bt_power */ PJ_12
+    );
+    return hci_driver;
+}
+
+#else
+
+ble::vendor::cordio::CordioHCIDriver& ble_cordio_get_hci_driver() {
+    static ble::vendor::cordio::H4TransportDriver transport_driver(
+        /* TX */ PA_2, /* RX */ PA_3, /* cts */ PA_0, /* rts */ PA_1, 115200
+    );
+    static ble::vendor::wise1530::HCIDriver hci_driver(
+        transport_driver, /* host wake */ PC_0, /* device wake */ PB_8, /* bt_power */ PC_6
+    );
+    return hci_driver;
+}
+
+#endif
\ No newline at end of file
diff --git a/features/netsocket/emac-drivers/TARGET_STM/TARGET_STM32H7/TARGET_PORTENTA_H7/stm32h7_eth_init.c b/features/netsocket/emac-drivers/TARGET_STM/TARGET_STM32H7/TARGET_PORTENTA_H7/stm32h7_eth_init.c
new file mode 100644
index 0000000000..38d9611ba4
--- /dev/null
+++ b/features/netsocket/emac-drivers/TARGET_STM/TARGET_STM32H7/TARGET_PORTENTA_H7/stm32h7_eth_init.c
@@ -0,0 +1,170 @@
+/* mbed Microcontroller Library
+ * Copyright (c) 2018, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define ETHERNET 1
+
+#ifndef USE_USER_DEFINED_HAL_ETH_MSPINIT
+
+#include "stm32h7xx_hal.h"
+
+#define ETH_TX_EN_Pin GPIO_PIN_11
+#define ETH_TX_EN_GPIO_Port GPIOG
+#define ETH_TXD1_Pin GPIO_PIN_12
+#define ETH_TXD1_GPIO_Port GPIOG
+#define ETH_TXD0_Pin GPIO_PIN_13
+#define ETH_TXD0_GPIO_Port GPIOG
+#define ETH_MDC_SAI4_D1_Pin GPIO_PIN_1
+#define ETH_MDC_SAI4_D1_GPIO_Port GPIOC
+#define ETH_MDIO_Pin GPIO_PIN_2
+#define ETH_MDIO_GPIO_Port GPIOA
+#define ETH_REF_CLK_Pin GPIO_PIN_1
+#define ETH_REF_CLK_GPIO_Port GPIOA
+#define ETH_CRS_DV_Pin GPIO_PIN_7
+#define ETH_CRS_DV_GPIO_Port GPIOA
+#define ETH_RXD0_Pin GPIO_PIN_4
+#define ETH_RXD0_GPIO_Port GPIOC
+#define ETH_RXD1_Pin GPIO_PIN_5
+#define ETH_RXD1_GPIO_Port GPIOC
+
+/**
+ * Override HAL Eth Init function
+ */
+void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
+{
+    GPIO_InitTypeDef GPIO_InitStruct;
+    if(heth->Instance == ETH)
+    {
+        #if !(defined(DUAL_CORE) && defined(CORE_CM4))
+        /* Disable DCache for STM32H7 family */
+        SCB_DisableDCache();
+        #endif
+
+        /* GPIO Ports Clock Enable */
+        __HAL_RCC_GPIOA_CLK_ENABLE();
+        // __HAL_RCC_GPIOB_CLK_ENABLE();
+        __HAL_RCC_GPIOC_CLK_ENABLE();
+        __HAL_RCC_GPIOG_CLK_ENABLE();
+        // __HAL_RCC_GPIOH_CLK_ENABLE();
+
+        /* Enable Peripheral clock */
+        __HAL_RCC_ETH1MAC_CLK_ENABLE();
+        __HAL_RCC_ETH1TX_CLK_ENABLE();
+        __HAL_RCC_ETH1RX_CLK_ENABLE();
+
+        /* Set pinstrap for 100mbit */
+        // TODO
+
+        /* Reset ETH Phy */
+        __HAL_RCC_GPIOJ_CLK_ENABLE();
+        GPIO_InitTypeDef  gpio_eth_rst_init_structure;
+        gpio_eth_rst_init_structure.Pin = GPIO_PIN_15;
+        gpio_eth_rst_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
+        gpio_eth_rst_init_structure.Pull = GPIO_NOPULL;
+        gpio_eth_rst_init_structure.Speed = GPIO_SPEED_FREQ_LOW;
+        HAL_GPIO_Init(GPIOJ, &gpio_eth_rst_init_structure);
+
+        gpio_eth_rst_init_structure.Pin = ETH_RXD0_Pin | ETH_RXD1_Pin;
+        HAL_GPIO_Init(GPIOC, &gpio_eth_rst_init_structure);
+        HAL_GPIO_WritePin(GPIOC, ETH_RXD0_Pin, 1);
+        HAL_GPIO_WritePin(GPIOC, ETH_RXD1_Pin, 1);
+        gpio_eth_rst_init_structure.Pin = ETH_CRS_DV_Pin;
+        HAL_GPIO_Init(GPIOA, &gpio_eth_rst_init_structure);
+        HAL_GPIO_WritePin(GPIOA, ETH_CRS_DV_Pin, 1);
+
+        HAL_GPIO_WritePin(GPIOJ, GPIO_PIN_15, 0);
+        HAL_Delay(100);
+        HAL_GPIO_WritePin(GPIOJ, GPIO_PIN_15, 1);
+
+        /**ETH GPIO Configuration
+        PG11     ------> ETH_TX_EN
+        PG12     ------> ETH_TXD1
+        PG13     ------> ETH_TXD0
+        PC1     ------> ETH_MDC
+        PA2     ------> ETH_MDIO
+        PA1     ------> ETH_REF_CLK
+        PA7     ------> ETH_CRS_DV
+        PC4     ------> ETH_RXD0
+        PC5     ------> ETH_RXD1
+        */
+        GPIO_InitStruct.Pin = ETH_TX_EN_Pin|ETH_TXD1_Pin|ETH_TXD0_Pin;
+        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+        GPIO_InitStruct.Pull = GPIO_NOPULL;
+        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+        GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
+        HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
+
+        GPIO_InitStruct.Pin = ETH_MDC_SAI4_D1_Pin|ETH_RXD0_Pin|ETH_RXD1_Pin;
+        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+        GPIO_InitStruct.Pull = GPIO_NOPULL;
+        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+        GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
+        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+        GPIO_InitStruct.Pin = ETH_MDIO_Pin|ETH_REF_CLK_Pin|ETH_CRS_DV_Pin;
+        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+        GPIO_InitStruct.Pull = GPIO_NOPULL;
+        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+        GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
+        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+    }
+}
+
+/**
+ * Override HAL Eth DeInit function
+ */
+void HAL_ETH_MspDeInit(ETH_HandleTypeDef *heth)
+{
+    if(heth->Instance == ETH)
+    {
+        /* Peripheral clock disable */
+        __HAL_RCC_ETH1MAC_CLK_DISABLE();
+        __HAL_RCC_ETH1TX_CLK_DISABLE();
+        __HAL_RCC_ETH1RX_CLK_DISABLE();
+
+        /**ETH GPIO Configuration
+        PG11     ------> ETH_TX_EN
+        PG12     ------> ETH_TXD1
+        PG13     ------> ETH_TXD0
+        PC1     ------> ETH_MDC
+        PA2     ------> ETH_MDIO
+        PA1     ------> ETH_REF_CLK
+        PA7     ------> ETH_CRS_DV
+        PC4     ------> ETH_RXD0
+        PC5     ------> ETH_RXD1
+        */
+        HAL_GPIO_DeInit(GPIOG, ETH_TX_EN_Pin|ETH_TXD1_Pin|ETH_TXD0_Pin);
+
+        HAL_GPIO_DeInit(GPIOC, ETH_MDC_SAI4_D1_Pin|ETH_RXD0_Pin|ETH_RXD1_Pin);
+
+        HAL_GPIO_DeInit(GPIOA, ETH_MDIO_Pin|ETH_REF_CLK_Pin|ETH_CRS_DV_Pin);
+
+        HAL_GPIO_WritePin(GPIOJ, GPIO_PIN_15, 0);
+    }
+}
+
+#endif /* USE_USER_DEFINED_HAL_ETH_MSPINIT */
diff --git a/features/netsocket/emac-drivers/TARGET_STM/stm32xx_emac.cpp b/features/netsocket/emac-drivers/TARGET_STM/stm32xx_emac.cpp
index 7ae8276cf6..950ef4a1dd 100644
--- a/features/netsocket/emac-drivers/TARGET_STM/stm32xx_emac.cpp
+++ b/features/netsocket/emac-drivers/TARGET_STM/stm32xx_emac.cpp
@@ -654,8 +654,10 @@ int STM32_EMAC::low_level_input(emac_mem_buf_t **buf)
         /* Build Rx descriptor to be ready for next data reception */
         HAL_ETH_BuildRxDescriptors(&EthHandle);
 
+#if !(defined(DUAL_CORE) && defined(CORE_CM4))
         /* Invalidate data cache for ETH Rx Buffers */
         SCB_InvalidateDCache_by_Addr((uint32_t *)RxBuff.buffer, frameLength);
+#endif
 
         *buf = pbuf_alloc(PBUF_RAW, frameLength, PBUF_POOL);
         if (*buf) {
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralNames.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralNames.h
new file mode 100644
index 0000000000..e52003787f
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralNames.h
@@ -0,0 +1,106 @@
+/* mbed Microcontroller Library
+ *******************************************************************************
+ * Copyright (c) 2016, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ */
+#ifndef MBED_PERIPHERALNAMES_H
+#define MBED_PERIPHERALNAMES_H
+
+#include "cmsis.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    ADC_1 = (int)ADC1_BASE,
+    ADC_2 = (int)ADC2_BASE,
+    ADC_3 = (int)ADC3_BASE
+} ADCName;
+
+typedef enum {
+    DAC_1 = DAC1_BASE
+} DACName;
+
+typedef enum {
+    UART_1 = (int)USART1_BASE,
+    UART_2 = (int)USART2_BASE,
+    UART_3 = (int)USART3_BASE,
+    UART_4 = (int)UART4_BASE,
+    UART_5 = (int)UART5_BASE,
+    UART_6 = (int)USART6_BASE,
+    UART_7 = (int)UART7_BASE,
+    UART_8 = (int)UART8_BASE,
+    LPUART_1 = (int)LPUART1_BASE
+} UARTName;
+
+typedef enum {
+    SPI_1 = (int)SPI1_BASE,
+    SPI_2 = (int)SPI2_BASE,
+    SPI_3 = (int)SPI3_BASE,
+    SPI_4 = (int)SPI4_BASE,
+    SPI_5 = (int)SPI5_BASE,
+    SPI_6 = (int)SPI6_BASE
+} SPIName;
+
+typedef enum {
+    I2C_1 = (int)I2C1_BASE,
+    I2C_2 = (int)I2C2_BASE,
+    I2C_3 = (int)I2C3_BASE,
+    I2C_4 = (int)I2C4_BASE
+} I2CName;
+
+typedef enum {
+    PWM_I  = (int)HRTIM1_BASE,
+    PWM_1  = (int)TIM1_BASE,
+    PWM_2  = (int)TIM2_BASE,
+    PWM_3  = (int)TIM3_BASE,
+    PWM_4  = (int)TIM4_BASE,
+    PWM_5  = (int)TIM5_BASE,
+    PWM_8  = (int)TIM8_BASE,
+    PWM_12 = (int)TIM12_BASE,
+    PWM_13 = (int)TIM13_BASE,
+    PWM_14 = (int)TIM14_BASE,
+    PWM_15 = (int)TIM15_BASE,
+    PWM_16 = (int)TIM16_BASE,
+    PWM_17 = (int)TIM17_BASE
+} PWMName;
+
+typedef enum {
+    CAN_1 = (int)FDCAN1_BASE,
+    CAN_2 = (int)FDCAN2_BASE
+} CANName;
+
+typedef enum {
+    QSPI_1 = (int)QSPI_R_BASE,
+} QSPIName;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralPins.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralPins.c
new file mode 100644
index 0000000000..7fe76b5bfc
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PeripheralPins.c
@@ -0,0 +1,599 @@
+/* mbed Microcontroller Library
+ *******************************************************************************
+ * Copyright (c) 2019, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ *
+ * Automatically generated from STM32H747XIHx.xml
+ */
+
+#include "PeripheralPins.h"
+#include "mbed_toolchain.h"
+
+//==============================================================================
+// Notes
+//
+// - The pins mentioned Px_y_ALTz are alternative possibilities which use other
+//   HW peripheral instances. You can use them the same way as any other "normal"
+//   pin (i.e. PwmOut pwm(PA_7_ALT0);). These pins are not displayed on the board
+//   pinout image on mbed.org.
+//
+// - The pins which are connected to other components present on the board have
+//   the comment "Connected to xxx". The pin function may not work properly in this
+//   case. These pins may not be displayed on the board pinout image on mbed.org.
+//   Please read the board reference manual and schematic for more information.
+//
+// - Warning: pins connected to the default STDIO_UART_TX and STDIO_UART_RX pins are commented
+//   See https://os.mbed.com/teams/ST/wiki/STDIO for more information.
+//
+//==============================================================================
+
+
+//*** ADC ***
+
+MBED_WEAK const PinMap PinMap_ADC[] = {
+    {PA_0,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 16, 0)}, // ADC1_INP16 // Connected to PMOD\#1- USART2_CTS_NSS
+    {PA_0_C,     ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC1_INN1 // Connected to ARD_A2
+    {PA_0_C_ALT0,ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 0, 0)}, // ADC1_INP0 // Connected to ARD_A2
+    {PA_0_C_ALT1,ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC2_INN1 // Connected to ARD_A2
+    {PA_0_C_ALT2,ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 0, 0)}, // ADC2_INP0 // Connected to ARD_A2
+    {PA_1,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 16, 0)}, // ADC1_INN16 // Connected to ETH_REF_CLK
+    {PA_1_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 17, 0)}, // ADC1_INP17 // Connected to ETH_REF_CLK
+    {PA_1_C,     ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC1_INP1 // Connected to ARD_A3
+    {PA_1_C_ALT0,ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC2_INP1 // Connected to ARD_A3
+    {PA_2,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC1_INP14 // Connected to ETH_MDIO
+    {PA_2_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC2_INP14 // Connected to ETH_MDIO
+    {PA_3,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC1_INP15 // Connected to ULPI_D0
+    {PA_3_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC2_INP15 // Connected to ULPI_D0
+    {PA_4,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 18, 0)}, // ADC1_INP18
+    {PA_4_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 18, 0)}, // ADC2_INP18
+    {PA_5,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 18, 0)}, // ADC1_INN18 // Connected to ULPI_CK
+    {PA_5_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 19, 0)}, // ADC1_INP19 // Connected to ULPI_CK
+    {PA_5_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 18, 0)}, // ADC2_INN18 // Connected to ULPI_CK
+    {PA_5_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 19, 0)}, // ADC2_INP19 // Connected to ULPI_CK
+    {PA_6,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC1_INP3
+    {PA_6_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC2_INP3
+    {PA_7,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC1_INN3 // Connected to ETH_CRS_DV
+    {PA_7_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 7, 0)}, // ADC1_INP7 // Connected to ETH_CRS_DV
+    {PA_7_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC2_INN3 // Connected to ETH_CRS_DV
+    {PA_7_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 7, 0)}, // ADC2_INP7 // Connected to ETH_CRS_DV
+    {PB_0,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC1_INN5 // Connected to ULPI_D1
+    {PB_0_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 9, 0)}, // ADC1_INP9 // Connected to ULPI_D1
+    {PB_0_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC2_INN5 // Connected to ULPI_D1
+    {PB_0_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 9, 0)}, // ADC2_INP9 // Connected to ULPI_D1
+    {PB_1,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC1_INP5 // Connected to ULPI_D2
+    {PB_1_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC2_INP5 // Connected to ULPI_D2
+    {PC_0,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC1_INP10 // Connected to ULPI_STP
+    {PC_0_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC2_INP10 // Connected to ULPI_STP
+    {PC_0_ALT1,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC3_INP10 // Connected to ULPI_STP
+    {PC_1,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC1_INN10 // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_1_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC1_INP11 // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_1_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC2_INN10 // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_1_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC2_INP11 // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_1_ALT3,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC3_INN10 // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_1_ALT4,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC3_INP11 // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_2,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC1_INN11 // Connected to PMOD\#3
+    {PC_2_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC1_INP12 // Connected to PMOD\#3
+    {PC_2_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC2_INN11 // Connected to PMOD\#3
+    {PC_2_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC2_INP12 // Connected to PMOD\#3
+    {PC_2_ALT3,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC3_INN11 // Connected to PMOD\#3
+    {PC_2_ALT4,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC3_INP12 // Connected to PMOD\#3
+    {PC_2_C,     ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC3_INN1 // Connected to ARD_A4
+    {PC_2_C_ALT0,ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 0, 0)}, // ADC3_INP0 // Connected to ARD_A4
+    {PC_3,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC1_INN12 // Connected to PMOD\#2
+    {PC_3_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 13, 0)}, // ADC1_INP13 // Connected to PMOD\#2
+    {PC_3_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC2_INN12 // Connected to PMOD\#2
+    {PC_3_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 13, 0)}, // ADC2_INP13 // Connected to PMOD\#2
+    {PC_3_C,     ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC3_INP1 // Connected to ARD_A5
+    {PC_4,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC1_INP4 // Connected to ETH_RXD0
+    {PC_4_ALT0,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC2_INP4 // Connected to ETH_RXD0
+    {PC_5,       ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC1_INN4 // Connected to ETH_RXD1
+    {PC_5_ALT0,  ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 8, 0)}, // ADC1_INP8 // Connected to ETH_RXD1
+    {PC_5_ALT1,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC2_INN4 // Connected to ETH_RXD1
+    {PC_5_ALT2,  ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 8, 0)}, // ADC2_INP8 // Connected to ETH_RXD1
+    {PF_3,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC3_INP5 // Connected to FMC_A3
+    {PF_4,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC3_INN5 // Connected to FMC_A4
+    {PF_4_ALT0,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 9, 0)}, // ADC3_INP9 // Connected to FMC_A4
+    {PF_5,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC3_INP4 // Connected to FMC_A5
+    {PF_6,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC3_INN4 // Connected to QSPI_BK1_IO3
+    {PF_6_ALT0,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 8, 0)}, // ADC3_INP8 // Connected to QSPI_BK1_IO3
+    {PF_7,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC3_INP3 // Connected to QSPI_BK1_IO2
+    {PF_8,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC3_INN3 // Connected to PMOD\#14/ARD_D3
+    {PF_8_ALT0,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 7, 0)}, // ADC3_INP7 // Connected to PMOD\#14/ARD_D3
+    {PF_9,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC3_INP2 // Connected to QSPI_BK1_IO1
+    {PF_10,      ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC3_INN2 // Connected to ARD_A1
+    {PF_10_ALT0, ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 6, 0)}, // ADC3_INP6 // Connected to ARD_A1
+    {PF_11,      ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC1_INP2 // Connected to FMC_SDRAS
+    {PF_12,      ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC1_INN2 // Connected to FMC_A6
+    {PF_12_ALT0, ADC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 6, 0)}, // ADC1_INP6 // Connected to FMC_A6
+    {PF_13,      ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC2_INP2 // Connected to FMC_A7
+    {PF_14,      ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC2_INN2 // Connected to FMC_A8
+    {PF_14_ALT0, ADC_2, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 6, 0)}, // ADC2_INP6 // Connected to FMC_A8
+    {PH_2,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 13, 0)}, // ADC3_INP13 // Connected to QSPI_BK2_IO0
+    {PH_3,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 13, 0)}, // ADC3_INN13 // Connected to QSPI_BK2_IO1
+    {PH_3_ALT0,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC3_INP14 // Connected to QSPI_BK2_IO1
+    {PH_4,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC3_INN14 // Connected to ULPI_NXT
+    {PH_4_ALT0,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC3_INP15 // Connected to ULPI_NXT
+    {PH_5,       ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC3_INN15 // Connected to FMC_SDNWE
+    {PH_5_ALT0,  ADC_3, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 16, 0)}, // ADC3_INP16 // Connected to FMC_SDNWE
+    {NC, NC, 0}
+};
+
+// !!! SECTION TO BE CHECKED WITH DEVICE REFERENCE MANUAL
+MBED_WEAK const PinMap PinMap_ADC_Internal[] = {
+    {ADC_TEMP,   ADC_1,    STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 16, 0)},
+    {ADC_VREF,   ADC_1,    STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 17, 0)},
+    {ADC_VBAT,   ADC_1,    STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 18, 0)},
+    {NC, NC, 0}
+};
+
+//*** DAC ***
+
+MBED_WEAK const PinMap PinMap_DAC[] = {
+    {PA_4,       DAC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // DAC1_OUT1
+    {PA_5,       DAC_1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // DAC1_OUT2 // Connected to ULPI_CK
+    {NC, NC, 0}
+};
+
+//*** I2C ***
+
+MBED_WEAK const PinMap PinMap_I2C_SDA[] = {
+    {PB_7,       I2C_1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+    {PB_7_ALT0,  I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C4)},
+    {PB_9,       I2C_1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)}, // Connected to PMOD\#19_DFSDM-DATA7
+    {PB_9_ALT0,  I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C4)}, // Connected to PMOD\#19_DFSDM-DATA7
+    {PB_11,      I2C_2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)}, // Connected to ULPI_D4
+    {PC_9,       I2C_3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)}, // Connected to SDIO1_D1
+    {PD_13,      I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C4)},
+    {PF_0,       I2C_2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)}, // Connected to FMC_A0
+    {PF_15,      I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C4)}, // Connected to FMC_A9
+    {PH_5,       I2C_2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)}, // Connected to FMC_SDNWE
+    {PH_8,       I2C_3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)}, // Connected to FMC_D16
+    {PH_12,      I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C4)}, // Connected to FMC_D20
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_I2C_SCL[] = {
+    {PA_8,       I2C_3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)}, // Connected to CEC_CK/MCO1
+    {PB_6,       I2C_1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)}, // Connected to HDMI_CEC
+    {PB_6_ALT0,  I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C4)}, // Connected to HDMI_CEC
+    {PB_8,       I2C_1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)}, // Connected to PMOD\#20_DFSDM-CK7
+    {PB_8_ALT0,  I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF6_I2C4)}, // Connected to PMOD\#20_DFSDM-CK7
+    {PB_10,      I2C_2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)}, // Connected to ULPI_D3
+    {PD_12,      I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C4)},
+    {PF_1,       I2C_2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)}, // Connected to FMC_A1
+    {PF_14,      I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C4)}, // Connected to FMC_A8
+    {PH_4,       I2C_2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)}, // Connected to ULPI_NXT
+    {PH_7,       I2C_3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)}, // Connected to FMC_SDCKE1
+    {PH_11,      I2C_4, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C4)}, // Connected to FMC_D19
+    {NC, NC, 0}
+};
+
+//*** PWM ***
+
+// TIM5 cannot be used because already used by the us_ticker
+// TIM2 cannot be used because already used by the us_ticker (DUAL_CORE)
+MBED_WEAK const PinMap PinMap_PWM[] = {
+//  {PA_0,       PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)}, // TIM2_CH1
+//  {PA_0,       PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 1, 0)}, // TIM5_CH1
+//  {PA_1,       PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 2, 0)}, // TIM2_CH2 // Connected to ETH_REF_CLK
+//  {PA_1,       PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 2, 0)}, // TIM5_CH2 // Connected to ETH_REF_CLK
+    {PA_1,       PWM_15, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_TIM15, 1, 1)}, // TIM15_CH1N // Connected to ETH_REF_CLK
+//  {PA_2,       PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 3, 0)}, // TIM2_CH3 // Connected to ETH_MDIO
+//  {PA_2,       PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 3, 0)}, // TIM5_CH3 // Connected to ETH_MDIO
+    {PA_2,       PWM_15, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_TIM15, 1, 0)}, // TIM15_CH1 // Connected to ETH_MDIO
+//  {PA_3,       PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 4, 0)}, // TIM2_CH4 // Connected to ULPI_D0
+//  {PA_3,       PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 4, 0)}, // TIM5_CH4 // Connected to ULPI_D0
+    {PA_3,       PWM_15, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_TIM15, 2, 0)}, // TIM15_CH2 // Connected to ULPI_D0
+//  {PA_5,       PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)}, // TIM2_CH1 // Connected to ULPI_CK
+    {PA_5,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)}, // TIM8_CH1N // Connected to ULPI_CK
+    {PA_6,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)}, // TIM3_CH1
+    {PA_6_ALT0,  PWM_13, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM13, 1, 0)}, // TIM13_CH1
+    {PA_7,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N // Connected to ETH_CRS_DV
+    {PA_7_ALT0,  PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)}, // TIM3_CH2 // Connected to ETH_CRS_DV
+    {PA_7_ALT1,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)}, // TIM8_CH1N // Connected to ETH_CRS_DV
+    {PA_7_ALT2,  PWM_14, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM14, 1, 0)}, // TIM14_CH1 // Connected to ETH_CRS_DV
+    {PA_8,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 0)}, // TIM1_CH1 // Connected to CEC_CK/MCO1
+//  {PA_9,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 0)}, // TIM1_CH2 // Connected to STDIO_UART_TX
+//  {PA_10,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 0)}, // TIM1_CH3 // Connected to STDIO_UART_RX
+    {PA_11,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 4, 0)}, // TIM1_CH4 // Connected to PMOD\#1
+//  {PA_15,      PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)}, // TIM2_CH1
+    {PB_0,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N // Connected to ULPI_D1
+    {PB_0_ALT0,  PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 3, 0)}, // TIM3_CH3 // Connected to ULPI_D1
+    {PB_0_ALT1,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N // Connected to ULPI_D1
+    {PB_1,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N // Connected to ULPI_D2
+    {PB_1_ALT0,  PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 4, 0)}, // TIM3_CH4 // Connected to ULPI_D2
+    {PB_1_ALT1,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)}, // TIM8_CH3N // Connected to ULPI_D2
+//  {PB_3,       PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 2, 0)}, // TIM2_CH2
+    {PB_4,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)}, // TIM3_CH1
+    {PB_5,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)}, // TIM3_CH2 // Connected to ULPI_D7
+    {PB_6,       PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 1, 0)}, // TIM4_CH1 // Connected to HDMI_CEC
+    {PB_6_ALT0,  PWM_16, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM16, 1, 1)}, // TIM16_CH1N // Connected to HDMI_CEC
+    {PB_7,       PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 2, 0)}, // TIM4_CH2
+    {PB_7_ALT0,  PWM_17, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM17, 1, 1)}, // TIM17_CH1N
+    {PB_8,       PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 3, 0)}, // TIM4_CH3 // Connected to PMOD\#20_DFSDM-CK7
+    {PB_8_ALT0,  PWM_16, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM16, 1, 0)}, // TIM16_CH1 // Connected to PMOD\#20_DFSDM-CK7
+    {PB_9,       PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 4, 0)}, // TIM4_CH4 // Connected to PMOD\#19_DFSDM-DATA7
+    {PB_9_ALT0,  PWM_17, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM17, 1, 0)}, // TIM17_CH1 // Connected to PMOD\#19_DFSDM-DATA7
+//  {PB_10,      PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 3, 0)}, // TIM2_CH3 // Connected to ULPI_D3
+//  {PB_11,      PWM_2,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 4, 0)}, // TIM2_CH4 // Connected to ULPI_D4
+    {PB_13,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N // Connected to ULPI_D6
+    {PB_14,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N // Connected to PMOD\#9
+    {PB_14_ALT0, PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N // Connected to PMOD\#9
+    {PB_14_ALT1, PWM_12, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM12, 1, 0)}, // TIM12_CH1 // Connected to PMOD\#9
+    {PB_15,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N // Connected to PMOD\#8
+    {PB_15_ALT0, PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)}, // TIM8_CH3N // Connected to PMOD\#8
+    {PB_15_ALT1, PWM_12, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM12, 2, 0)}, // TIM12_CH2 // Connected to PMOD\#8
+    {PC_6,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)}, // TIM3_CH1
+    {PC_6_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 0)}, // TIM8_CH1
+    {PC_7,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)}, // TIM3_CH2 // Connected to PMOD\#17_DFSDM_DATA3
+    {PC_7_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 0)}, // TIM8_CH2 // Connected to PMOD\#17_DFSDM_DATA3
+    {PC_8,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 3, 0)}, // TIM3_CH3 // Connected to SDIO1_D0
+    {PC_8_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 0)}, // TIM8_CH3 // Connected to SDIO1_D0
+    {PC_9,       PWM_3,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 4, 0)}, // TIM3_CH4 // Connected to SDIO1_D1
+    {PC_9_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 4, 0)}, // TIM8_CH4 // Connected to SDIO1_D1
+    {PD_12,      PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 1, 0)}, // TIM4_CH1
+    {PD_13,      PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 2, 0)}, // TIM4_CH2
+    {PD_14,      PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 3, 0)}, // TIM4_CH3 // Connected to FMC_D0
+    {PD_15,      PWM_4,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 4, 0)}, // TIM4_CH4 // Connected to FMC_D1
+    {PE_4,       PWM_15, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_TIM15, 1, 1)}, // TIM15_CH1N // Connected to SAI1_FS_A
+    {PE_5,       PWM_15, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_TIM15, 1, 0)}, // TIM15_CH1 // Connected to SAI1_SCK_A
+    {PE_6,       PWM_15, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_TIM15, 2, 0)}, // TIM15_CH2 // Connected to SAI1_SD_A
+    {PE_8,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N // Connected to FMC_D5
+    {PE_9,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 0)}, // TIM1_CH1 // Connected to FMC_D6
+    {PE_10,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N // Connected to FMC_D7
+    {PE_11,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 0)}, // TIM1_CH2 // Connected to FMC_D8
+    {PE_12,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N // Connected to FMC_D9
+    {PE_13,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 0)}, // TIM1_CH3 // Connected to FMC_D10
+    {PE_14,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 4, 0)}, // TIM1_CH4 // Connected to FMC_D11
+    {PF_6,       PWM_16, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM16, 1, 0)}, // TIM16_CH1 // Connected to QSPI_BK1_IO3
+    {PF_7,       PWM_17, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM17, 1, 0)}, // TIM17_CH1 // Connected to QSPI_BK1_IO2
+    {PF_8,       PWM_13, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM13, 1, 0)}, // TIM13_CH1 // Connected to PMOD\#14/ARD_D3
+    {PF_8_ALT0,  PWM_16, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM16, 1, 1)}, // TIM16_CH1N // Connected to PMOD\#14/ARD_D3
+    {PF_9,       PWM_14, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM14, 1, 0)}, // TIM14_CH1 // Connected to QSPI_BK1_IO1
+    {PF_9_ALT0,  PWM_17, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM17, 1, 1)}, // TIM17_CH1N // Connected to QSPI_BK1_IO1
+    {PH_6,       PWM_12, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM12, 1, 0)}, // TIM12_CH1 // Connected to FMC_SDNE1
+    {PH_9,       PWM_12, STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM12, 2, 0)}, // TIM12_CH2 // Connected to FMC_D17
+//  {PH_10,      PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 1, 0)}, // TIM5_CH1 // Connected to FMC_D18
+//  {PH_11,      PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 2, 0)}, // TIM5_CH2 // Connected to FMC_D19
+//  {PH_12,      PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 3, 0)}, // TIM5_CH3 // Connected to FMC_D20
+    {PH_13,      PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)}, // TIM8_CH1N // Connected to FMC_D21
+    {PH_14,      PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N // Connected to FMC_D22
+    {PH_15,      PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)}, // TIM8_CH3N // Connected to FMC_D23
+//  {PI_0,       PWM_5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 4, 0)}, // TIM5_CH4 // Connected to FMC_D24
+    {PI_2,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 4, 0)}, // TIM8_CH4 // Connected to FMC_D26
+    {PI_5,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 0)}, // TIM8_CH1 // Connected to FMC_NBL3
+    {PI_6,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 0)}, // TIM8_CH2 // Connected to FMC_D28
+    {PI_7,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 0)}, // TIM8_CH3 // Connected to FMC_D29
+    {PJ_6,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 0)}, // TIM8_CH2 // Connected to ARD_D9
+    {PJ_7,       PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N // Connected to ARD_D6
+    {PJ_8,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N // Connected to ARD_D1
+    {PJ_8_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 0)}, // TIM8_CH1 // Connected to ARD_D1
+    {PJ_9,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 0)}, // TIM1_CH3 // Connected to ARD_D0
+    {PJ_9_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)}, // TIM8_CH1N // Connected to ARD_D0
+    {PJ_10,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N // Connected to ARD_D11
+    {PJ_10_ALT0, PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 0)}, // TIM8_CH2 // Connected to ARD_D11
+    {PJ_11,      PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 0)}, // TIM1_CH2 // Connected to ARD_D12
+    {PJ_11_ALT0, PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N // Connected to ARD_D12
+    {PK_0,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N // Connected to ARD_D13
+    {PK_0_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 0)}, // TIM8_CH3 // Connected to ARD_D13
+    {PK_1,       PWM_1,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 0)}, // TIM1_CH1 // Connected to ARD_D10
+    {PK_1_ALT0,  PWM_8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)}, // TIM8_CH3N // Connected to ARD_D10
+    {NC, NC, 0}
+};
+
+//*** SERIAL ***
+
+MBED_WEAK const PinMap PinMap_UART_TX[] = {
+    {PA_0,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to PMOD\#1- USART2_CTS_NSS
+    {PA_2,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to ETH_MDIO
+    {PA_9,       UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)}, // Connected to STDIO_UART_TX
+    {PA_9_ALT0,  LPUART_1,STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_LPUART)}, // Connected to STDIO_UART_TX
+    {PA_12,      UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_UART4)}, // Connected to SPI2_SCK
+    {PA_15,      UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF11_UART7)},
+    {PB_4,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF11_UART7)},
+    {PB_6,       UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)}, // Connected to HDMI_CEC
+    {PB_6_ALT0,  UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF14_UART5)}, // Connected to HDMI_CEC
+    {PB_6_ALT1,  LPUART_1,STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_LPUART)}, // Connected to HDMI_CEC
+    {PB_9,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to PMOD\#19_DFSDM-DATA7
+    {PB_10,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to ULPI_D3
+    {PB_13,      UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF14_UART5)}, // Connected to ULPI_D6
+    {PB_14,      UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_USART1)}, // Connected to PMOD\#9
+    {PC_6,       UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)},
+    {PC_10,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to SDIO1_D2
+    {PC_10_ALT0, UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to SDIO1_D2
+    {PC_12,      UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)}, // Connected to SDIO1_CK
+    {PD_1,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to FMC_D3
+    {PD_5,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to STDIO_UART_TX
+    {PD_8,       UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to FMC_D13
+    {PE_1,       UART_8,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART8)}, // Connected to FMC_NBL1
+    {PE_8,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to FMC_D5
+    {PF_7,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to QSPI_BK1_IO2
+    {PG_14,      UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to QSPI_BK2_IO3
+    {PH_13,      UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to FMC_D21
+    {PJ_8,       UART_8,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART8)}, // Connected to ARD_D1
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_UART_RX[] = {
+    {PA_1,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to ETH_REF_CLK
+    {PA_3,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to ULPI_D0
+    {PA_8,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF11_UART7)}, // Connected to CEC_CK/MCO1
+    {PA_10,      UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)}, // Connected to STDIO_UART_RX
+    {PA_10_ALT0, LPUART_1,STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_LPUART)}, // Connected to STDIO_UART_RX
+    {PA_11,      UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_UART4)}, // Connected to PMOD\#1
+    {PB_3,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF11_UART7)},
+    {PB_5,       UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF14_UART5)}, // Connected to ULPI_D7
+    {PB_7,       UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+    {PB_7_ALT0,  LPUART_1,STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_LPUART)},
+    {PB_8,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to PMOD\#20_DFSDM-CK7
+    {PB_11,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to ULPI_D4
+    {PB_12,      UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF14_UART5)}, // Connected to ULPI_D5
+    {PB_15,      UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF4_USART1)}, // Connected to PMOD\#8
+    {PC_7,       UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to PMOD\#17_DFSDM_DATA3
+    {PC_11,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to SDIO1_D3
+    {PC_11_ALT0, UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to SDIO1_D3
+    {PD_0,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to FMC_D2
+    {PD_2,       UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)}, // Connected to SDIO1_CMD
+    {PD_6,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to STDIO_UART_RX
+    {PD_9,       UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to FMC_D14
+    {PE_0,       UART_8,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART8)}, // Connected to FMC_NBL0
+    {PE_7,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to FMC_D4
+    {PF_6,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to QSPI_BK1_IO3
+    {PG_9,       UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to QSPI_BK2_IO2
+    {PH_14,      UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to FMC_D22
+    {PI_9,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to FMC_D30
+    {PJ_9,       UART_8,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART8)}, // Connected to ARD_D0
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_UART_RTS[] = {
+    {PA_1,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to ETH_REF_CLK
+    {PA_12,      UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)}, // Connected to SPI2_SCK
+    {PA_12_ALT0, LPUART_1,STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_LPUART)}, // Connected to SPI2_SCK
+    {PA_15,      UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+    {PB_14,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to PMOD\#9
+    {PB_14_ALT0, UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to PMOD\#9
+    {PC_8,       UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)}, // Connected to SDIO1_D0
+    {PD_4,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to PMOD\#4- USART2_RTS
+    {PD_12,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+    {PD_15,      UART_8,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART8)}, // Connected to FMC_D1
+    {PE_9,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to FMC_D6
+    {PF_8,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to PMOD\#14/ARD_D3
+    {PG_8,       UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to FMC_SDCLK
+    {PG_12,      UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to ETH_TXD1
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_UART_CTS[] = {
+    {PA_0,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to PMOD\#1- USART2_CTS_NSS
+    {PA_11,      UART_1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)}, // Connected to PMOD\#1
+    {PA_11_ALT0, LPUART_1,STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_LPUART)}, // Connected to PMOD\#1
+    {PB_0,       UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to ULPI_D1
+    {PB_13,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to ULPI_D6
+    {PB_15,      UART_4,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)}, // Connected to PMOD\#8
+    {PC_9,       UART_5,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)}, // Connected to SDIO1_D1
+    {PD_3,       UART_2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)}, // Connected to PMOD\#18_DFSDM_CKOUT
+    {PD_11,      UART_3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)}, // Connected to QSPI_BK1_IO0
+    {PD_14,      UART_8,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART8)}, // Connected to FMC_D0
+    {PE_10,      UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to FMC_D7
+    {PF_9,       UART_7,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_UART7)}, // Connected to QSPI_BK1_IO1
+    {PG_13,      UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to ETH_TXD0
+    {PG_15,      UART_6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART6)}, // Connected to FMC_SDCAS
+    {NC, NC, 0}
+};
+
+//*** SPI ***
+
+MBED_WEAK const PinMap PinMap_SPI_MOSI[] = {
+    {PA_7,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)}, // Connected to ETH_CRS_DV
+    {PA_7_ALT0,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)}, // Connected to ETH_CRS_DV
+    {PB_2,       SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF7_SPI3)}, // Connected to QSPI_CLK
+    {PB_5,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)}, // Connected to ULPI_D7
+    {PB_5_ALT0,  SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF7_SPI3)}, // Connected to ULPI_D7
+    {PB_5_ALT1,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)}, // Connected to ULPI_D7
+    {PB_15,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#8
+    {PC_1,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to SAI4_D1 (default: SB8 off/SB21 on), ETH_MDC (SB8 on/SB21 off)
+    {PC_3,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#2
+    {PC_12,      SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)}, // Connected to SDIO1_CK
+    {PD_6,       SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI3)},
+    {PD_7,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)}, // Connected to SPDIF_RX0
+    {PE_6,       SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to SAI1_SD_A
+    {PE_14,      SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to FMC_D11
+    {PF_9,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to QSPI_BK1_IO1
+    {PF_11,      SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to FMC_SDRAS
+    {PG_14,      SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI6)}, // Connected to QSPI_BK2_IO3
+    {PI_3,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to FMC_D27
+    {PJ_10,      SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to ARD_D11
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_SPI_MISO[] = {
+    {PA_6,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)},
+    {PA_6_ALT0,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)},
+    {PB_4,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)},
+    {PB_4_ALT0,  SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)},
+    {PB_4_ALT1,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)},
+    {PB_14,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#9
+    {PC_2,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#3
+    {PC_11,      SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)}, // Connected to SDIO1_D3
+    {PE_5,       SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to SAI1_SCK_A
+    {PE_13,      SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to FMC_D10
+    {PF_8,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to PMOD\#14/ARD_D3
+    {PG_9,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)}, // Connected to QSPI_BK2_IO2
+    {PG_12,      SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI6)}, // Connected to ETH_TXD1
+    {PH_7,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to FMC_SDCKE1
+    {PI_2,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to FMC_D26
+    {PJ_11,      SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to ARD_D12
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_SPI_SCLK[] = {
+    {PA_5,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)}, // Connected to ULPI_CK
+    {PA_5_ALT0,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)}, // Connected to ULPI_CK
+//  {PA_9,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to STDIO_UART_TX
+    {PA_12,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to SPI2_SCK
+    {PB_3,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)},
+    {PB_3_ALT0,  SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)},
+    {PB_3_ALT1,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)},
+    {PB_10,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to ULPI_D3
+    {PB_13,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to ULPI_D6
+    {PC_10,      SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)}, // Connected to SDIO1_D2
+    {PD_3,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#18_DFSDM_CKOUT
+    {PE_2,       SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to SAI4_CK1 (default: R87 on/SB17 off), ETH_nINT (R87 off/SB17 on)
+    {PE_12,      SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to FMC_D9
+    {PF_7,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to QSPI_BK1_IO2
+    {PG_11,      SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)}, // Connected to ETH_TX_EN
+    {PG_13,      SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI6)}, // Connected to ETH_TXD0
+    {PH_6,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to FMC_SDNE1
+    {PI_1,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to FMC_D25
+    {PK_0,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to ARD_D13
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_SPI_SSEL[] = {
+    {PA_4,       SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)},
+    {PA_4_ALT0,  SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)},
+    {PA_4_ALT1,  SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF8_SPI6)},
+    {PA_11,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#1
+    {PA_15,      SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)},
+    {PA_15_ALT0, SPI_3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF6_SPI3)},
+    {PA_15_ALT1, SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF7_SPI6)},
+    {PB_4,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF7_SPI2)},
+    {PB_9,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to PMOD\#19_DFSDM-DATA7
+    {PB_12,      SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to ULPI_D5
+    {PE_4,       SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to SAI1_FS_A
+    {PE_11,      SPI_4, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI4)}, // Connected to FMC_D8
+    {PF_6,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to QSPI_BK1_IO3
+    {PG_8,       SPI_6, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI6)}, // Connected to FMC_SDCLK
+    {PG_10,      SPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI1)},
+    {PH_5,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to FMC_SDNWE
+    {PI_0,       SPI_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI2)}, // Connected to FMC_D24
+    {PK_1,       SPI_5, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF5_SPI5)}, // Connected to ARD_D10
+    {NC, NC, 0}
+};
+
+//*** CAN ***
+
+MBED_WEAK const PinMap PinMap_CAN_RD[] = {
+    {PA_11,      CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to PMOD\#1
+    {PB_5,       CAN_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN2)}, // Connected to ULPI_D7
+    {PB_8,       CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to PMOD\#20_DFSDM-CK7
+    {PB_12,      CAN_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN2)}, // Connected to ULPI_D5
+    {PD_0,       CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to FMC_D2
+    {PH_14,      CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to FMC_D22
+    {PI_9,       CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to FMC_D30
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_CAN_TD[] = {
+    {PA_12,      CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to SPI2_SCK
+    {PB_6,       CAN_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN2)}, // Connected to HDMI_CEC
+    {PB_9,       CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to PMOD\#19_DFSDM-DATA7
+    {PB_13,      CAN_2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN2)}, // Connected to ULPI_D6
+    {PD_1,       CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to FMC_D3
+    {PH_13,      CAN_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF9_FDCAN1)}, // Connected to FMC_D21
+    {NC, NC, 0}
+};
+
+//*** QUADSPI ***
+
+MBED_WEAK const PinMap PinMap_QSPI_DATA0[] = {
+    {PC_9,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO0 // Connected to SDIO1_D1
+    {PD_11,     QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO0 // Connected to QSPI_BK1_IO0
+    {PF_8,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_QUADSPI)},  // QUADSPI_BK1_IO0 // Connected to PMOD\#14/ARD_D3
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_QSPI_DATA1[] = {
+    {PC_10,     QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO1 // Connected to SDIO1_D2
+    {PD_12,     QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO1
+    {PF_9,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_QUADSPI)},  // QUADSPI_BK1_IO1 // Connected to QSPI_BK1_IO1
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_QSPI_DATA2[] = {
+    {PE_2,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO2 // Connected to SAI4_CK1 (default: R87 on/SB17 off), ETH_nINT (R87 off/SB17 on)
+    {PF_7,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO2 // Connected to QSPI_BK1_IO2
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_QSPI_DATA3[] = {
+    {PA_1,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO3 // Connected to ETH_REF_CLK
+    {PD_13,     QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO3
+    {PF_6,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_IO3 // Connected to QSPI_BK1_IO3
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_QSPI_SCLK[] = {
+    {PB_2,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_CLK // Connected to QSPI_CLK
+    {PF_10,     QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_CLK // Connected to ARD_A1
+    {NC, NC, 0}
+};
+
+MBED_WEAK const PinMap PinMap_QSPI_SSEL[] = {
+    {PB_6,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_QUADSPI)},  // QUADSPI_BK1_NCS // Connected to HDMI_CEC
+    {PB_10,     QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_QUADSPI)},  // QUADSPI_BK1_NCS // Connected to ULPI_D3
+    {PG_6,      QSPI_1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_QUADSPI)},  // QUADSPI_BK1_NCS // Connected to QSPI_BK1_NCS
+    {NC, NC, 0}
+};
+
+//*** USBDEVICE ***
+
+MBED_WEAK const PinMap PinMap_USB_FS[] = {
+//  {PA_8,      USB_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG1_FS)}, // USB_OTG_FS_SOF // Connected to CEC_CK/MCO1
+//  {PA_9,      USB_FS, STM_PIN_DATA(STM_MODE_INPUT, GPIO_NOPULL, GPIO_AF_NONE)}, // USB_OTG_FS_VBUS // Connected to STDIO_UART_TX
+//  {PA_10,     USB_FS, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_PULLUP, GPIO_AF10_OTG1_FS)}, // USB_OTG_FS_ID // Connected to STDIO_UART_RX
+    {PA_11,     USB_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG1_FS)}, // USB_OTG_FS_DM // Connected to PMOD\#1
+    {PA_12,     USB_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG1_FS)}, // USB_OTG_FS_DP // Connected to SPI2_SCK
+    {NC, NC, 0}
+};
+
+//*** USBDEVICE ***
+
+MBED_WEAK const PinMap PinMap_USB_HS[] = {
+#if (MBED_CONF_TARGET_USB_SPEED == USE_USB_HS_IN_FS)
+//  {PA_4,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_OTG2_FS)}, // USB_OTG_HS_SOF
+    {PB_12,     USB_HS, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_PULLUP, GPIO_AF12_OTG2_FS)}, // USB_OTG_HS_ID // Connected to ULPI_D5
+    {PB_13,     USB_HS, STM_PIN_DATA(STM_MODE_INPUT, GPIO_NOPULL, GPIO_AF_NONE)}, // USB_OTG_HS_VBUS // Connected to ULPI_D6
+    {PB_14,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_OTG2_FS)}, // USB_OTG_HS_DM // Connected to PMOD\#9
+    {PB_15,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_OTG2_FS)}, // USB_OTG_HS_DP // Connected to PMOD\#8
+#else /* MBED_CONF_TARGET_USB_SPEED */
+    {PA_5,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_CK // Connected to ULPI_CK
+    {PC_0,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_STP // Connected to ULPI_STP
+    {PH_4,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_NXT // Connected to ULPI_NXT
+    {PI_11,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_DIR // Connected to ULPI_DIR
+    {PA_3,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D0 // Connected to ULPI_D0
+    {PB_0,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D1 // Connected to ULPI_D1
+    {PB_1,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D2 // Connected to ULPI_D2
+    {PB_10,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D3 // Connected to ULPI_D3
+    {PB_11,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D4 // Connected to ULPI_D4
+    {PB_12,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D5 // Connected to ULPI_D5
+    {PB_13,     USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D6 // Connected to ULPI_D6
+    {PB_5,      USB_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG2_HS)}, // USB_OTG_HS_ULPI_D7 // Connected to ULPI_D7
+#endif /* MBED_CONF_TARGET_USB_SPEED */
+    {NC, NC, 0}
+};
\ No newline at end of file
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PinNames.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PinNames.h
new file mode 100644
index 0000000000..fab4537b6e
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/PinNames.h
@@ -0,0 +1,448 @@
+/* mbed Microcontroller Library
+ *******************************************************************************
+ * Copyright (c) 2018, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ */
+#ifndef MBED_PINNAMES_H
+#define MBED_PINNAMES_H
+
+#include "cmsis.h"
+#include "PinNamesTypes.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    ALT0  = 0x100,
+    ALT1  = 0x200,
+    ALT2  = 0x300,
+    ALT3  = 0x400,
+    ALT4  = 0x500,
+    ALT6  = 0x700,
+    ALTC  = 0x1000
+} ALTx;
+
+typedef enum {
+    PA_0  = 0x00,
+    PA_0_C = PA_0 | ALTC,
+    PA_0_C_ALT0 = PA_0 | ALT0 | ALTC,
+    PA_0_C_ALT1 = PA_0 | ALT1 | ALTC,
+    PA_0_C_ALT2 = PA_0 | ALT2 | ALTC,
+    PA_1  = 0x01,
+    PA_1_ALT0 = PA_1 | ALT0,
+    PA_1_C = PA_1 | ALTC,
+    PA_1_C_ALT0 = PA_1 | ALT0 | ALTC,
+    PA_2  = 0x02,
+    PA_2_ALT0 = PA_2 | ALT0,
+    PA_2_ALT1 = PA_2 | ALT1,
+    PA_3  = 0x03,
+    PA_3_ALT0 = PA_3 | ALT0,
+    PA_3_ALT1 = PA_3 | ALT1,
+    PA_4  = 0x04,
+    PA_4_ALT0 = PA_4 | ALT0,
+    PA_4_ALT1 = PA_4 | ALT1,
+    PA_5  = 0x05,
+    PA_5_ALT0 = PA_5 | ALT0,
+    PA_5_ALT1 = PA_5 | ALT1,
+    PA_5_ALT2 = PA_5 | ALT2,
+    PA_6  = 0x06,
+    PA_6_ALT0 = PA_6 | ALT0,
+    PA_7  = 0x07,
+    PA_7_ALT0 = PA_7 | ALT0,
+    PA_7_ALT1 = PA_7 | ALT1,
+    PA_7_ALT2 = PA_7 | ALT2,
+    PA_8  = 0x08,
+    PA_9  = 0x09,
+    PA_9_ALT0 = PA_9 | ALT0,
+    PA_10 = 0x0A,
+    PA_10_ALT0 = PA_10 | ALT0,
+    PA_11 = 0x0B,
+    PA_11_ALT0 = PA_11 | ALT0,
+    PA_12 = 0x0C,
+    PA_12_ALT0 = PA_12 | ALT0,
+    PA_13 = 0x0D,
+    PA_14 = 0x0E,
+    PA_15 = 0x0F,
+    PA_15_ALT0 = PA_15 | ALT0,
+    PA_15_ALT1 = PA_15 | ALT1,
+
+    PB_0  = 0x10,
+    PB_0_ALT0 = PB_0 | ALT0,
+    PB_0_ALT1 = PB_0 | ALT1,
+    PB_0_ALT2 = PB_0 | ALT2,
+    PB_1  = 0x11,
+    PB_1_ALT0 = PB_1 | ALT0,
+    PB_1_ALT1 = PB_1 | ALT1,
+    PB_2  = 0x12,
+    PB_3  = 0x13,
+    PB_3_ALT0 = PB_3 | ALT0,
+    PB_3_ALT1 = PB_3 | ALT1,
+    PB_4  = 0x14,
+    PB_4_ALT0 = PB_4 | ALT0,
+    PB_4_ALT1 = PB_4 | ALT1,
+    PB_5  = 0x15,
+    PB_5_ALT0 = PB_5 | ALT0,
+    PB_5_ALT1 = PB_5 | ALT1,
+    PB_6  = 0x16,
+    PB_6_ALT0 = PB_6 | ALT0,
+    PB_6_ALT1 = PB_6 | ALT1,
+    PB_7  = 0x17,
+    PB_7_ALT0 = PB_7 | ALT0,
+    PB_8  = 0x18,
+    PB_8_ALT0 = PB_8 | ALT0,
+    PB_9  = 0x19,
+    PB_9_ALT0 = PB_9 | ALT0,
+    PB_10 = 0x1A,
+    PB_11 = 0x1B,
+    PB_12 = 0x1C,
+    PB_13 = 0x1D,
+    PB_14 = 0x1E,
+    PB_14_ALT0 = PB_14 | ALT0,
+    PB_14_ALT1 = PB_14 | ALT1,
+    PB_15 = 0x1F,
+    PB_15_ALT0 = PB_15 | ALT0,
+    PB_15_ALT1 = PB_15 | ALT1,
+
+    PC_0  = 0x20,
+    PC_0_ALT0 = PC_0 | ALT0,
+    PC_0_ALT1 = PC_0 | ALT1,
+    PC_1  = 0x21,
+    PC_1_ALT0 = PC_1 | ALT0,
+    PC_1_ALT1 = PC_1 | ALT1,
+    PC_1_ALT2 = PC_1 | ALT2,
+    PC_1_ALT3 = PC_1 | ALT3,
+    PC_1_ALT4 = PC_1 | ALT4,
+    PC_2  = 0x22,
+    PC_2_ALT0 = PC_2 | ALT0,
+    PC_2_ALT1 = PC_2 | ALT1,
+    PC_2_ALT2 = PC_2 | ALT2,
+    PC_2_ALT3 = PC_2 | ALT3,
+    PC_2_ALT4 = PC_2 | ALT4,
+    PC_2_C  = PC_2 | ALTC,
+    PC_2_C_ALT0 = PC_2 | ALT0 | ALTC,
+    PC_3  = 0x23,
+    PC_3_ALT0 = PC_3 | ALT0,
+    PC_3_ALT1 = PC_3 | ALT1,
+    PC_3_ALT2 = PC_3 | ALT2,
+    PC_3_C  = PC_3 | ALTC,
+    PC_4  = 0x24,
+    PC_4_ALT0 = PC_4 | ALT0,
+    PC_5  = 0x25,
+    PC_5_ALT0 = PC_5 | ALT0,
+    PC_5_ALT1 = PC_5 | ALT1,
+    PC_5_ALT2 = PC_5 | ALT2,
+    PC_6  = 0x26,
+    PC_6_ALT0 = PC_6 | ALT0,
+    PC_7  = 0x27,
+    PC_7_ALT0 = PC_7 | ALT0,
+    PC_8  = 0x28,
+    PC_8_ALT0 = PC_8 | ALT0,
+    PC_9  = 0x29,
+    PC_9_ALT0 = PC_9 | ALT0,
+    PC_10 = 0x2A,
+    PC_10_ALT0 = PC_10 | ALT0,
+    PC_11 = 0x2B,
+    PC_11_ALT0 = PC_11 | ALT0,
+    PC_12 = 0x2C,
+    PC_13 = 0x2D,
+    PC_14 = 0x2E,
+    PC_15 = 0x2F,
+
+    PD_0  = 0x30,
+    PD_1  = 0x31,
+    PD_2  = 0x32,
+    PD_3  = 0x33,
+    PD_4  = 0x34,
+    PD_5  = 0x35,
+    PD_6  = 0x36,
+    PD_7  = 0x37,
+    PD_8  = 0x38,
+    PD_9  = 0x39,
+    PD_10 = 0x3A,
+    PD_11 = 0x3B,
+    PD_12 = 0x3C,
+    PD_13 = 0x3D,
+    PD_14 = 0x3E,
+    PD_15 = 0x3F,
+
+    PE_0  = 0x40,
+    PE_1  = 0x41,
+    PE_2  = 0x42,
+    PE_3  = 0x43,
+    PE_4  = 0x44,
+    PE_5  = 0x45,
+    PE_6  = 0x46,
+    PE_7  = 0x47,
+    PE_8  = 0x48,
+    PE_9  = 0x49,
+    PE_10 = 0x4A,
+    PE_11 = 0x4B,
+    PE_12 = 0x4C,
+    PE_13 = 0x4D,
+    PE_14 = 0x4E,
+    PE_15 = 0x4F,
+
+    PF_0  = 0x50,
+    PF_1  = 0x51,
+    PF_2  = 0x52,
+    PF_3  = 0x53,
+    PF_4  = 0x54,
+    PF_4_ALT0 = PF_4 | ALT0,
+    PF_5  = 0x55,
+    PF_6  = 0x56,
+    PF_6_ALT0 = PF_6 | ALT0,
+    PF_7  = 0x57,
+    PF_8  = 0x58,
+    PF_8_ALT0 = PF_8 | ALT0,
+    PF_9  = 0x59,
+    PF_9_ALT0 = PF_9 | ALT0,
+    PF_10 = 0x5A,
+    PF_10_ALT0 = PF_10 | ALT0,
+    PF_11 = 0x5B,
+    PF_12 = 0x5C,
+    PF_12_ALT0 = PF_12 | ALT0,
+    PF_13 = 0x5D,
+    PF_14 = 0x5E,
+    PF_14_ALT0 = PF_14 | ALT0,
+    PF_15 = 0x5F,
+
+    PG_0  = 0x60,
+    PG_1  = 0x61,
+    PG_2  = 0x62,
+    PG_3  = 0x63,
+    PG_4  = 0x64,
+    PG_5  = 0x65,
+    PG_6  = 0x66,
+    PG_7  = 0x67,
+    PG_8  = 0x68,
+    PG_9  = 0x69,
+    PG_10 = 0x6A,
+    PG_11 = 0x6B,
+    PG_12 = 0x6C,
+    PG_13 = 0x6D,
+    PG_14 = 0x6E,
+    PG_15 = 0x6F,
+
+    PH_0  = 0x70,
+    PH_1  = 0x71,
+    PH_2  = 0x72,
+    PH_3  = 0x73,
+    PH_3_ALT0 = PH_3 | ALT0,
+    PH_4  = 0x74,
+    PH_4_ALT0 = PH_4 | ALT0,
+    PH_5  = 0x75,
+    PH_5_ALT0 = PH_5 | ALT0,
+    PH_6  = 0x76,
+    PH_7  = 0x77,
+    PH_8  = 0x78,
+    PH_9  = 0x79,
+    PH_10 = 0x7A,
+    PH_11 = 0x7B,
+    PH_12 = 0x7C,
+    PH_13 = 0x7D,
+    PH_14 = 0x7E,
+    PH_15 = 0x7F,
+
+    PI_0  = 0x80,
+    PI_1  = 0x81,
+    PI_2  = 0x82,
+    PI_3  = 0x83,
+    PI_4  = 0x84,
+    PI_5  = 0x85,
+    PI_6  = 0x86,
+    PI_7  = 0x87,
+    PI_8  = 0x88,
+    PI_9  = 0x89,
+    PI_10 = 0x8A,
+    PI_11 = 0x8B,
+    PI_12 = 0x8C,
+    PI_13 = 0x8D,
+    PI_14 = 0x8E,
+    PI_15 = 0x8F,
+
+    PJ_0  = 0x90,
+    PJ_1  = 0x91,
+    PJ_2  = 0x92,
+    PJ_3  = 0x93,
+    PJ_4  = 0x94,
+    PJ_5  = 0x95,
+    PJ_6  = 0x96,
+    PJ_7  = 0x97,
+    PJ_8  = 0x98,
+    PJ_8_ALT0 = PJ_8 | ALT0,
+    PJ_9  = 0x99,
+    PJ_9_ALT0 = PJ_9 | ALT0,
+    PJ_10 = 0x9A,
+    PJ_10_ALT0 = PJ_10 | ALT0,
+    PJ_11 = 0x9B,
+    PJ_11_ALT0 = PJ_11 | ALT0,
+    PJ_12 = 0x9C,
+    PJ_13 = 0x9D,
+    PJ_14 = 0x9E,
+    PJ_15 = 0x9F,
+
+    PK_0  = 0xA0,
+    PK_0_ALT0 = PK_0 | ALT0,
+    PK_1  = 0xA1,
+    PK_1_ALT0 = PK_1 | ALT0,
+    PK_2  = 0xA2,
+    PK_3  = 0xA3,
+    PK_4  = 0xA4,
+    PK_5  = 0xA5,
+    PK_6  = 0xA6,
+    PK_7  = 0xA7,
+    PK_8  = 0xA8,
+    PK_9  = 0xA9,
+    PK_10 = 0xAA,
+    PK_11 = 0xAB,
+    PK_12 = 0xAC,
+    PK_13 = 0xAD,
+    PK_14 = 0xAE,
+    PK_15 = 0xAF,
+
+    // ADC internal channels
+    ADC_TEMP = 0xF0,
+    ADC_VREF = 0xF1,
+    ADC_VBAT = 0xF2,
+
+    // STDIO for console print
+#ifdef MBED_CONF_TARGET_STDIO_UART_TX
+    STDIO_UART_TX = MBED_CONF_TARGET_STDIO_UART_TX,
+#else
+    STDIO_UART_TX = PA_9,
+#endif
+#ifdef MBED_CONF_TARGET_STDIO_UART_RX
+    STDIO_UART_RX = MBED_CONF_TARGET_STDIO_UART_RX,
+#else
+    STDIO_UART_RX = PA_10,
+#endif
+
+    //Led mappings
+    LED_RED = PK_5,  //Red
+    LED_GREEN = PK_6,  //Green
+    LED_BLUE = PK_7,  //Blue
+
+    //mbed original LED naming
+    LED1 = LED_RED,
+    LED2 = LED_GREEN,
+    LED3 = LED_BLUE,
+
+    USER_BUTTON = PC_13,
+    // Standardized button names
+    BUTTON1 = USER_BUTTON,
+    SERIAL_TX   = STDIO_UART_TX, // Virtual Com Port
+    SERIAL_RX   = STDIO_UART_RX, // Virtual Com Port
+    USBTX       = STDIO_UART_TX, // Virtual Com Port
+    USBRX       = STDIO_UART_RX, // Virtual Com Port
+    I2C_SCL     = PB_6,
+    I2C_SDA     = PB_7,
+    PWM_OUT     = PD_15,
+
+    /**** QSPI FLASH pins ****/
+    QSPI_FLASH1_IO0 = PD_11,
+    QSPI_FLASH1_IO1 = PD_12,
+    QSPI_FLASH1_IO2 = PF_7,
+    QSPI_FLASH1_IO3 = PD_13,
+    QSPI_FLASH1_SCK = PF_10,
+    QSPI_FLASH1_CSN = PG_6,
+
+    /**** USB pins ****/
+    USB_OTG_FS_DM = PA_11,
+    USB_OTG_FS_DP = PA_12,
+    USB_OTG_FS_ID = PA_10,
+    USB_OTG_FS_SOF = PA_8,
+    USB_OTG_FS_VBUS = PA_9,
+    USB_OTG_HS_DM = PB_14,
+    USB_OTG_HS_DP = PB_15,
+    USB_OTG_HS_ID = PB_12,
+    USB_OTG_HS_SOF = PA_4,
+    USB_OTG_HS_ULPI_CK = PA_5,
+    USB_OTG_HS_ULPI_D0 = PA_3,
+    USB_OTG_HS_ULPI_D1 = PB_0,
+    USB_OTG_HS_ULPI_D2 = PB_1,
+    USB_OTG_HS_ULPI_D3 = PB_10,
+    USB_OTG_HS_ULPI_D4 = PB_11,
+    USB_OTG_HS_ULPI_D5 = PB_12,
+    USB_OTG_HS_ULPI_D6 = PB_13,
+    USB_OTG_HS_ULPI_D7 = PB_5,
+    USB_OTG_HS_ULPI_DIR = PC_2,
+    USB_OTG_HS_ULPI_NXT = PC_3,
+    USB_OTG_HS_ULPI_STP = PC_0,
+    USB_OTG_HS_VBUS = PB_13,
+
+    /**** ETHERNET pins ****/
+    ETH_MDC = PC_1,
+    ETH_MDIO = PA_2,
+    ETH_CRS_DV = PA_7,
+    ETH_REF_CLK = PA_1,
+    ETH_RXD0 = PC_4,
+    ETH_RXD1 = PC_5,
+    ETH_RX_CLK = PA_1,
+    ETH_TXD0 = PG_13,
+    ETH_TXD1 = PG_12,
+    ETH_TX_EN = PG_11,
+
+    /**** OSCILLATOR pins ****/
+    RCC_OSC32_IN = PC_14,
+    RCC_OSC32_OUT = PC_15,
+    RCC_OSC_IN = PH_0,
+    RCC_OSC_OUT = PH_1,
+
+    /**** DEBUG pins ****/
+    SYS_JTCK_SWCLK = PA_14,
+    SYS_JTDI = PA_15,
+    SYS_JTDO_SWO = PB_3,
+    SYS_JTMS_SWDIO = PA_13,
+    SYS_JTRST = PB_4,
+    SYS_PVD_IN = PB_7,
+    SYS_TRACECLK = PE_2,
+    SYS_TRACED0 = PE_3,
+    SYS_TRACED0_ALT0 = PC_1,
+    SYS_TRACED0_ALT1 = PG_13,
+    SYS_TRACED1 = PE_4,
+    SYS_TRACED1_ALT0 = PC_8,
+    SYS_TRACED1_ALT1 = PG_14,
+    SYS_TRACED2 = PE_5,
+    SYS_TRACED2_ALT0 = PD_2,
+    SYS_TRACED3 = PE_6,
+    SYS_TRACED3_ALT0 = PC_12,
+    SYS_TRGIO = PC_7,
+    SYS_WKUP0 = PA_0,
+    SYS_WKUP1 = PA_2,
+    SYS_WKUP2 = PC_13,
+    SYS_WKUP5 = PC_1,
+
+    // Not connected
+    NC = (int)0xFFFFFFFF
+} PinName;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_clock.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_clock.c
new file mode 100644
index 0000000000..013b8bc1a2
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_clock.c
@@ -0,0 +1,227 @@
+/*
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
+  * All rights reserved.</center></h2>
+  *
+  * This software component is licensed by ST under BSD 3-Clause license,
+  * the "License"; You may not use this file except in compliance with the
+  * License. You may obtain a copy of the License at:
+  *                        opensource.org/licenses/BSD-3-Clause
+  *
+  ******************************************************************************
+*/
+
+/**
+  * This file configures the system clock as follows:
+  *--------------------------------------------------------------------
+  * System clock source   | 1- USE_PLL_HSE_EXTC (external 8 MHz clock)
+  *                       | 2- USE_PLL_HSE_XTAL (external 8 MHz xtal)
+  *                       | 3- USE_PLL_HSI (internal 64 MHz clock)
+  *--------------------------------------------------------------------
+  * SYSCLK(MHz)           |            480
+  * AHBCLK (MHz)          |            240
+  * APB1CLK (MHz)         |            120
+  * APB2CLK (MHz)         |            120
+  * APB3CLK (MHz)         |            120
+  * APB4CLK (MHz)         |            120
+  * USB capable (48 MHz)  |            YES
+  *--------------------------------------------------------------------
+**/
+
+#include "stm32h7xx.h"
+#include "nvic_addr.h"
+#include "mbed_error.h"
+
+/*!< Uncomment the following line if you need to relocate your vector Table in
+     Internal SRAM. */
+/* #define VECT_TAB_SRAM */
+#define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field. 
+                                   This value must be a multiple of 0x200. */
+
+// clock source is selected with CLOCK_SOURCE in json config
+#define USE_PLL_HSE_EXTC     0x8  // Use external clock (ST Link MCO)
+#define USE_PLL_HSE_XTAL     0x4  // Use external xtal (X3 on board - not provided by default)
+#define USE_PLL_HSI          0x2  // Use HSI internal clock
+
+#if ( ((CLOCK_SOURCE) & USE_PLL_HSE_XTAL) || ((CLOCK_SOURCE) & USE_PLL_HSE_EXTC) )
+uint8_t SetSysClock_PLL_HSE(uint8_t bypass);
+#endif /* ((CLOCK_SOURCE) & USE_PLL_HSE_XTAL) || ((CLOCK_SOURCE) & USE_PLL_HSE_EXTC) */
+
+#if ((CLOCK_SOURCE) & USE_PLL_HSI)
+uint8_t SetSysClock_PLL_HSI(void);
+#endif /* ((CLOCK_SOURCE) & USE_PLL_HSI) */
+
+/**
+  * @brief  Configures the System clock source, PLL Multiplier and Divider factors,
+  *               AHB/APBx prescalers and Flash settings
+  * @note   This function should be called only once the RCC clock configuration
+  *         is reset to the default reset state (done in SystemInit() function).
+  * @param  None
+  * @retval None
+  */
+
+void SetSysClock(void)
+{
+#if ((CLOCK_SOURCE) & USE_PLL_HSE_EXTC)
+    /* 1- Try to start with HSE and external clock (MCO from STLink PCB part) */
+    if (SetSysClock_PLL_HSE(1) == 0)
+#endif
+    {
+#if ((CLOCK_SOURCE) & USE_PLL_HSE_XTAL)
+        /* 2- If fail try to start with HSE and external xtal */
+        if (SetSysClock_PLL_HSE(0) == 0)
+#endif
+        {
+#if ((CLOCK_SOURCE) & USE_PLL_HSI)
+            /* 3- If fail start with HSI clock */
+            if (SetSysClock_PLL_HSI() == 0)
+#endif
+            {
+                error("SetSysClock failed\n");
+            }
+        }
+    }
+}
+
+#if ( ((CLOCK_SOURCE) & USE_PLL_HSE_XTAL) || ((CLOCK_SOURCE) & USE_PLL_HSE_EXTC) )
+/******************************************************************************/
+/*            PLL (clocked by HSE) used as System clock source                */
+/******************************************************************************/
+uint8_t SetSysClock_PLL_HSE(uint8_t bypass)
+{
+    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
+    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
+    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
+
+    /* Enable oscillator pin */
+    __HAL_RCC_GPIOH_CLK_ENABLE();
+    GPIO_InitTypeDef  gpio_osc_init_structure;
+    gpio_osc_init_structure.Pin = GPIO_PIN_1;
+    gpio_osc_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
+    gpio_osc_init_structure.Pull = GPIO_PULLUP;
+    gpio_osc_init_structure.Speed = GPIO_SPEED_FREQ_LOW;
+    HAL_GPIO_Init(GPIOH, &gpio_osc_init_structure);
+    HAL_Delay(10);
+    HAL_GPIO_WritePin(GPIOH, GPIO_PIN_1, 1);
+
+    /* Supply configuration update enable */
+    HAL_PWREx_ConfigSupply(PWR_SMPS_1V8_SUPPLIES_LDO);
+    /* Configure the main internal regulator output voltage */
+    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
+
+    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
+
+    /* Enable HSE Oscillator and activate PLL with HSE as source */
+    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI48;
+    if (bypass) {
+        RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
+    } else {
+        RCC_OscInitStruct.HSEState = RCC_HSE_ON;
+    }
+    RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
+    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
+    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
+    RCC_OscInitStruct.PLL.PLLM = 9;
+    RCC_OscInitStruct.PLL.PLLN = 300;
+    RCC_OscInitStruct.PLL.PLLFRACN = 0;
+    RCC_OscInitStruct.PLL.PLLP = 2;
+    RCC_OscInitStruct.PLL.PLLR = 2;
+    RCC_OscInitStruct.PLL.PLLQ = 10;
+    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
+    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
+    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
+        return 0; // FAIL
+    }
+
+    /* Select PLL as system clock source and configure bus clocks dividers */
+    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
+                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |
+                                  RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_D3PCLK1;
+    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
+    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
+    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
+    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
+    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
+    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
+    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
+    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
+        return 0; // FAIL
+    }
+
+    // HAL_RCCEx_EnableBootCore(RCC_BOOT_C2);
+
+#if DEVICE_USBDEVICE
+    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
+    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
+    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) {
+        return 0; // FAIL
+    }
+
+    HAL_PWREx_EnableUSBVoltageDetector();
+#endif /* DEVICE_USBDEVICE */
+
+    __HAL_RCC_CSI_ENABLE() ;
+
+    __HAL_RCC_SYSCFG_CLK_ENABLE() ;
+
+    HAL_EnableCompensationCell();
+
+    return 1; // OK
+}
+#endif /* ((CLOCK_SOURCE) & USE_PLL_HSE_XTAL) || ((CLOCK_SOURCE) & USE_PLL_HSE_EXTC) */
+
+#if ((CLOCK_SOURCE) & USE_PLL_HSI)
+/******************************************************************************/
+/*            PLL (clocked by HSI) used as System clock source                */
+/******************************************************************************/
+uint8_t SetSysClock_PLL_HSI(void)
+{
+    RCC_ClkInitTypeDef RCC_ClkInitStruct;
+    RCC_OscInitTypeDef RCC_OscInitStruct;
+
+    /*!< Supply configuration update enable */
+    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
+    /* The voltage scaling allows optimizing the power consumption when the device is
+    clocked below the maximum system frequency, to update the voltage scaling value
+    regarding system frequency refer to product datasheet.  */
+    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
+    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
+
+    // Enable HSI oscillator and activate PLL with HSI as source
+    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_CSI;
+    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
+    RCC_OscInitStruct.HSEState = RCC_HSE_OFF;
+    RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
+    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
+    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
+    RCC_OscInitStruct.PLL.PLLM = 8;
+    RCC_OscInitStruct.PLL.PLLN = 113;
+    RCC_OscInitStruct.PLL.PLLP = 2;
+    RCC_OscInitStruct.PLL.PLLQ = 10;
+    RCC_OscInitStruct.PLL.PLLR = 2;
+    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
+    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
+    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
+    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
+        return 0; // FAIL
+    }
+
+    /* Select PLL as system clock source and configure  bus clocks dividers */
+    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \
+                                   RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1);
+    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
+    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
+    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
+    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
+    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
+    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
+    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
+    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
+        return 0; // FAIL
+    }
+
+    return 1; // OK
+}
+#endif /* ((CLOCK_SOURCE) & USE_PLL_HSI) */
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_stm32h7xx.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_stm32h7xx.c
new file mode 100644
index 0000000000..f39a7c3472
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/system_stm32h7xx.c
@@ -0,0 +1,390 @@
+/**
+  ******************************************************************************
+  * @file    system_stm32h7xx_dualcore_boot_cm4_cm7.c
+  * @author  MCD Application Team
+  * @brief   CMSIS Cortex-Mx Device Peripheral Access Layer System Source File.
+  *          This provides system initialization template function is case of
+  *          an application using a dual core STM32H7 device where
+  *          Cortex-M7 and Cortex-M4 boot are enabled at the FLASH option bytes
+  *
+  *   This file provides two functions and one global variable to be called from
+  *   user application:
+  *      - SystemInit(): This function is called at startup just after reset and
+  *                      before branch to main program. This call is made inside
+  *                      the "startup_stm32h7xx.s" file.
+  *
+  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
+  *                                  by the user application to setup the SysTick
+  *                                  timer or configure other parameters.
+  *
+  *      - SystemCoreClockUpdate(): Updates the variables SystemD1Clock and SystemD2Clock
+  *                                 and must be called whenever the core clock is changed
+  *                                 during program execution.
+  *
+  *
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
+  * All rights reserved.</center></h2>
+  *
+  * This software component is licensed by ST under BSD 3-Clause license,
+  * the "License"; You may not use this file except in compliance with the
+  * License. You may obtain a copy of the License at:
+  *                        opensource.org/licenses/BSD-3-Clause
+  *
+  ******************************************************************************
+  */
+
+/** @addtogroup CMSIS
+  * @{
+  */
+
+/** @addtogroup stm32h7xx_system
+  * @{
+  */
+
+/** @addtogroup STM32H7xx_System_Private_Includes
+  * @{
+  */
+
+#include "stm32h7xx.h"
+#include <math.h>
+#include "nvic_addr.h" // MBED PATCH for Bootloader
+
+#if !defined  (HSE_VALUE)
+#define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
+#endif /* HSE_VALUE */
+
+#if !defined  (CSI_VALUE)
+  #define CSI_VALUE    ((uint32_t)4000000) /*!< Value of the Internal oscillator in Hz*/
+#endif /* CSI_VALUE */
+
+#if !defined  (HSI_VALUE)
+  #define HSI_VALUE    ((uint32_t)64000000) /*!< Value of the Internal oscillator in Hz*/
+#endif /* HSI_VALUE */
+
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32H7xx_System_Private_TypesDefinitions
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32H7xx_System_Private_Defines
+  * @{
+  */
+
+/************************* Miscellaneous Configuration ************************/
+/*!< Uncomment the following line if you need to relocate your vector Table in
+     Internal SRAM. */
+/* #define VECT_TAB_SRAM */
+#define VECT_TAB_OFFSET  0x00000000UL /*!< Vector Table base offset field.
+                                      This value must be a multiple of 0x200. */
+/******************************************************************************/
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32H7xx_System_Private_Macros
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32H7xx_System_Private_Variables
+  * @{
+  */
+  /* This variable is updated in three ways:
+      1) by calling CMSIS function SystemCoreClockUpdate()
+      2) by calling HAL API function HAL_RCC_GetHCLKFreq()
+      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
+         Note: If you use this function to configure the system clock; then there
+               is no need to call the 2 first functions listed above, since SystemCoreClock
+               variable is updated automatically.
+  */
+#if defined(CORE_CM7)
+#define SystemCoreClock   SystemD1Clock
+#elif defined(CORE_CM4)
+#define SystemCoreClock   SystemD2Clock
+#else
+#error "Wrong core selection"
+#endif
+  uint32_t SystemD1Clock = 64000000;
+  uint32_t SystemD2Clock = 64000000;
+  const  uint8_t D1CorePrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32H7xx_System_Private_FunctionPrototypes
+  * @{
+  */
+
+/**
+  * @}
+  */
+
+/** @addtogroup STM32H7xx_System_Private_Functions
+  * @{
+  */
+
+/**
+  * @brief  Setup the microcontroller system
+  *         Initialize the FPU setting and  vector table location
+  *         configuration.
+  * @param  None
+  * @retval None
+  */
+void SystemInit (void)
+{
+  /* FPU settings ------------------------------------------------------------*/
+  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
+  #endif
+
+    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
+     detectable by the CPU after a WFI/WFE instruction.*/
+ SCB->SCR |= SCB_SCR_SEVONPEND_Pos;
+
+#ifdef CORE_CM7
+  /* Reset the RCC clock configuration to the default reset state ------------*/
+  /* Set HSION bit */
+  RCC->CR |= RCC_CR_HSION;
+
+  /* Reset CFGR register */
+  RCC->CFGR = 0x00000000;
+
+  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
+  RCC->CR &= 0xEAF6ED7FU;
+
+  /* Reset D1CFGR register */
+  RCC->D1CFGR = 0x00000000;
+
+  /* Reset D2CFGR register */
+  RCC->D2CFGR = 0x00000000;
+
+  /* Reset D3CFGR register */
+  RCC->D3CFGR = 0x00000000;
+
+  /* Reset PLLCKSELR register */
+  RCC->PLLCKSELR = 0x00000000;
+
+  /* Reset PLLCFGR register */
+  RCC->PLLCFGR = 0x00000000;
+  /* Reset PLL1DIVR register */
+  RCC->PLL1DIVR = 0x00000000;
+  /* Reset PLL1FRACR register */
+  RCC->PLL1FRACR = 0x00000000;
+
+  /* Reset PLL2DIVR register */
+  RCC->PLL2DIVR = 0x00000000;
+
+  /* Reset PLL2FRACR register */
+
+  RCC->PLL2FRACR = 0x00000000;
+  /* Reset PLL3DIVR register */
+  RCC->PLL3DIVR = 0x00000000;
+
+  /* Reset PLL3FRACR register */
+  RCC->PLL3FRACR = 0x00000000;
+
+  /* Reset HSEBYP bit */
+  RCC->CR &= 0xFFFBFFFFU;
+
+  /* Disable all interrupts */
+  RCC->CIER = 0x00000000;
+
+  /* Enable CortexM7 HSEM EXTI line (line 78)*/
+  EXTI_D2->EMR3 |= 0x4000UL;
+
+
+  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
+  {
+    /* if stm32h7 revY*/
+    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
+    *((__IO uint32_t*)0x51008108) = 0x000000001U;
+  }
+
+#endif /* CORE_CM7*/
+
+#ifdef CORE_CM4
+
+  /* Configure the Vector Table location add offset address ------------------*/
+#ifdef VECT_TAB_SRAM
+  SCB->VTOR = D2_AHBSRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
+#else
+  SCB->VTOR = NVIC_FLASH_VECTOR_ADDRESS; /* Vector Table Relocation in Internal FLASH */ // MBED PATCH for Bootloader
+#endif
+
+#else
+#ifdef CORE_CM7
+
+  /* Configure the Vector Table location add offset address ------------------*/
+#ifdef VECT_TAB_SRAM
+  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
+#else
+  SCB->VTOR = NVIC_FLASH_VECTOR_ADDRESS; /* Vector Table Relocation in Internal FLASH */ // MBED PATCH for Bootloader
+#endif
+
+#else
+#error Please #define CORE_CM4 or CORE_CM7
+#endif
+#endif
+
+}
+
+#if defined (CORE_CM4)
+void HSEM2_IRQHandler(void)
+{
+  HAL_HSEM_IRQHandler();
+}
+#endif
+
+#if defined (CORE_CM7)
+void HSEM1_IRQHandler(void)
+{
+  HAL_HSEM_IRQHandler();
+}
+#endif
+
+/**
+   * @brief  Update SystemD1Clock and SystemD2Clock variables according to Clock Register Values.
+  *         The SystemCoreClock variable contains the core clock , it can
+  *         be used by the user application to setup the SysTick timer or configure
+  *         other parameters.
+  *
+  * @note   Each time the core clock changes, this function must be called
+  *         to update SystemCoreClock variable value. Otherwise, any configuration
+  *         based on this variable will be incorrect.
+  *
+  * @note   - The system frequency computed by this function is not the real
+  *           frequency in the chip. It is calculated based on the predefined
+  *           constant and the selected clock source:
+  *
+  *           - If SYSCLK source is CSI, SystemD1Clock will contain the CSI_VALUE(*)
+  *           - If SYSCLK source is HSI, SystemD1Clock will contain the HSI_VALUE(**)
+  *           - If SYSCLK source is HSE, SystemD1Clock will contain the HSE_VALUE(***)
+  *           - If SYSCLK source is PLL, SystemD1Clock will contain the CSI_VALUE(*),
+  *             HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.
+  *
+  *         (*) CSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
+  *             4 MHz) but the real value may vary depending on the variations
+  *             in voltage and temperature.
+  *         (**) HSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
+  *             64 MHz) but the real value may vary depending on the variations
+  *             in voltage and temperature.
+  *
+  *         (***)HSE_VALUE is a constant defined in stm32h7xx_hal.h file (default value
+  *              25 MHz), user has to ensure that HSE_VALUE is same as the real
+  *              frequency of the crystal used. Otherwise, this function may
+  *              have wrong result.
+  *
+  *         - The result of this function could be not correct when using fractional
+  *           value for HSE crystal.
+  * @param  None
+  * @retval None
+  */
+void SystemCoreClockUpdate (void)
+{
+  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue, tmp;
+  float_t fracn1, pllvco;
+
+  /* Get SYSCLK source -------------------------------------------------------*/
+
+  switch (RCC->CFGR & RCC_CFGR_SWS)
+  {
+  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
+   SystemD1Clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
+
+    break;
+
+  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
+    SystemD1Clock = CSI_VALUE;
+    break;
+
+  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
+    SystemD1Clock = HSE_VALUE;
+    break;
+
+  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */
+
+    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
+    SYSCLK = PLL_VCO / PLLR
+    */
+    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
+    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
+    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
+    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
+
+    if (pllm != 0U)
+    {
+      switch (pllsource)
+      {
+        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */
+
+        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
+        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
+
+        break;
+
+        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
+          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
+        break;
+
+        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
+          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
+        break;
+
+      default:
+          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
+        break;
+      }
+      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
+      SystemD1Clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
+    }
+    else
+    {
+      SystemD1Clock = 0U;
+    }
+    break;
+
+  default:
+    SystemD1Clock = CSI_VALUE;
+    break;
+  }
+
+  /* Compute SystemClock frequency --------------------------------------------------*/
+  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
+
+  /* SystemD1Clock frequency : CM7 CPU frequency  */
+  SystemD1Clock >>= tmp;
+
+  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
+  SystemD2Clock = (SystemD1Clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
+
+}
+
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+
+/**
+  * @}
+  */
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/STM32H747xI.ld b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/STM32H747xI.ld
new file mode 100644
index 0000000000..8289581c20
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/STM32H747xI.ld
@@ -0,0 +1,202 @@
+/* Linker script to configure memory regions. */
+
+#if !defined(MBED_APP_START)
+  #define MBED_APP_START 0x08100000
+#endif
+
+#if !defined(MBED_APP_SIZE)
+  #define MBED_APP_SIZE 1024K
+#endif
+
+#if !defined(RAM_START)
+  #define RAM_START 0x10000000
+#endif
+
+#if !defined(RAM_SIZE)
+  #define RAM_SIZE 288K
+#endif
+
+#if !defined(MBED_BOOT_STACK_SIZE)
+    #define MBED_BOOT_STACK_SIZE 0x400
+#endif
+
+STACK_SIZE = MBED_BOOT_STACK_SIZE;
+
+M_CRASH_DATA_RAM_SIZE = 0x100;
+
+/* 0x298 bytes is the size of vectors - see cmsis_nvic.h */
+
+MEMORY
+{
+  RAM (xrw)                     : ORIGIN = RAM_START + 0x298, LENGTH = RAM_SIZE - 0x298
+  OPENAMP_RSC_TAB (rwx)         : ORIGIN = 0x38000000, LENGTH = 1K
+  OPEN_AMP_SHMEM (rwx)          : ORIGIN = 0x38000400, LENGTH = 63K
+  FLASH (rx)                    : ORIGIN = MBED_APP_START, LENGTH = MBED_APP_SIZE
+}
+ __OPENAMP_region_start__  = ORIGIN(OPEN_AMP_SHMEM);
+ __OPENAMP_region_end__ = ORIGIN(OPEN_AMP_SHMEM) + LENGTH(OPEN_AMP_SHMEM);
+
+/* Linker script to place sections and symbol values. Should be used together
+ * with other linker script that defines memory regions FLASH and RAM.
+ * It references following symbols, which must be defined in code:
+ *   Reset_Handler : Entry of reset handler
+ * 
+ * It defines following symbols, which code can use without definition:
+ *   __exidx_start
+ *   __exidx_end
+ *   __etext
+ *   __data_start__
+ *   __preinit_array_start
+ *   __preinit_array_end
+ *   __init_array_start
+ *   __init_array_end
+ *   __fini_array_start
+ *   __fini_array_end
+ *   __data_end__
+ *   __bss_start__
+ *   __bss_end__
+ *   __end__
+ *   end
+ *   __HeapLimit
+ *   __StackLimit
+ *   __StackTop
+ *   __stack
+ *   _estack
+ */
+ENTRY(Reset_Handler)
+
+SECTIONS
+{
+    .text :
+    {
+        KEEP(*(.isr_vector))
+        *(.text*)
+        KEEP(*(.init))
+        KEEP(*(.fini))
+
+        /* .ctors */
+        *crtbegin.o(.ctors)
+        *crtbegin?.o(.ctors)
+        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
+        *(SORT(.ctors.*))
+        *(.ctors)
+
+        /* .dtors */
+        *crtbegin.o(.dtors)
+        *crtbegin?.o(.dtors)
+        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
+        *(SORT(.dtors.*))
+        *(.dtors)
+
+        *(.rodata*)
+
+        KEEP(*(.eh_frame*))
+    } > FLASH
+
+    .ARM.extab :
+    {
+        *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > FLASH
+
+    __exidx_start = .;
+    .ARM.exidx :
+    {
+        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > FLASH
+    __exidx_end = .;
+
+    __etext = .;
+    _sidata = .;
+    
+    .crash_data_ram :
+    {
+        . = ALIGN(8);
+        __CRASH_DATA_RAM__ = .;
+        __CRASH_DATA_RAM_START__ = .; /* Create a global symbol at data start */
+        KEEP(*(.keep.crash_data_ram))
+        *(.m_crash_data_ram)     /* This is a user defined section */
+        . += M_CRASH_DATA_RAM_SIZE;
+        . = ALIGN(8);
+        __CRASH_DATA_RAM_END__ = .; /* Define a global symbol at data end */
+    } > RAM
+
+    .data : AT (__etext)
+    {
+        __data_start__ = .;
+        _sdata = .;
+        *(vtable)
+        *(.data*)
+
+        . = ALIGN(8);
+        /* preinit data */
+        PROVIDE_HIDDEN (__preinit_array_start = .);
+        KEEP(*(.preinit_array))
+        PROVIDE_HIDDEN (__preinit_array_end = .);
+
+        . = ALIGN(8);
+        /* init data */
+        PROVIDE_HIDDEN (__init_array_start = .);
+        KEEP(*(SORT(.init_array.*)))
+        KEEP(*(.init_array))
+        PROVIDE_HIDDEN (__init_array_end = .);
+
+
+        . = ALIGN(8);
+        /* finit data */
+        PROVIDE_HIDDEN (__fini_array_start = .);
+        KEEP(*(SORT(.fini_array.*)))
+        KEEP(*(.fini_array))
+        PROVIDE_HIDDEN (__fini_array_end = .);
+
+        KEEP(*(.jcr*))
+        . = ALIGN(8);
+        /* All data end */
+        __data_end__ = .;
+        _edata = .;
+
+    } > RAM
+
+    .bss :
+    {
+        . = ALIGN(8);
+        __bss_start__ = .;
+        _sbss = .;
+        *(.bss*)
+        *(COMMON)
+        . = ALIGN(8);
+        __bss_end__ = .;
+        _ebss = .;
+    } > RAM
+
+    .heap (COPY):
+    {
+        __end__ = .;
+        end = __end__;
+        *(.heap*)
+        . = ORIGIN(RAM) + LENGTH(RAM) - STACK_SIZE;
+        __HeapLimit = .;
+    } > RAM
+
+    .openamp_section (NOLOAD) : {
+        . = ABSOLUTE(0x38000000);
+        *(.resource_table)
+    } >OPENAMP_RSC_TAB  AT > FLASH
+
+    /* .stack_dummy section doesn't contains any symbols. It is only
+     * used for linker to calculate size of stack sections, and assign
+     * values to stack symbols later */
+    .stack_dummy (COPY):
+    {
+        *(.stack*)
+    } > RAM
+
+    /* Set stack top to end of RAM, and stack limit move down by
+     * size of stack_dummy section */
+    __StackTop = ORIGIN(RAM) + LENGTH(RAM);
+    _estack = __StackTop;
+    __StackLimit = __StackTop - STACK_SIZE;
+    PROVIDE(__stack = __StackTop);
+
+    /* Check if data + heap + stack exceeds RAM limit */
+    ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")
+}
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S
new file mode 100644
index 0000000000..671eecd963
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M4/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S
@@ -0,0 +1,787 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32h743xx.s
+  * @author    MCD Application Team
+  * @brief     STM32H743xx Devices vector table for GCC based toolchain. 
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2017 STMicroelectronics</center></h2>
+  *
+  * Redistribution and use in source and binary forms, with or without modification,
+  * are permitted provided that the following conditions are met:
+  *   1. Redistributions of source code must retain the above copyright notice,
+  *      this list of conditions and the following disclaimer.
+  *   2. Redistributions in binary form must reproduce the above copyright notice,
+  *      this list of conditions and the following disclaimer in the documentation
+  *      and/or other materials provided with the distribution.
+  *   3. Neither the name of STMicroelectronics nor the names of its contributors
+  *      may be used to endorse or promote products derived from this software
+  *      without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  ******************************************************************************
+  */
+    
+  .syntax unified
+  .cpu cortex-m7
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section. 
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */  
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+/* stack used for SystemInit_ExtMemCtl; always internal RAM used */
+
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called. 
+ * @param  None
+ * @retval : None
+*/
+
+    .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:  
+  ldr   sp, =_estack      /* set stack pointer */
+
+/* Copy the data segment initializers from flash to SRAM */  
+  movs  r1, #0
+  b  LoopCopyDataInit
+
+CopyDataInit:
+  ldr  r3, =_sidata
+  ldr  r3, [r3, r1]
+  str  r3, [r0, r1]
+  adds  r1, r1, #4
+    
+LoopCopyDataInit:
+  ldr  r0, =_sdata
+  ldr  r3, =_edata
+  adds  r2, r0, r1
+  cmp  r2, r3
+  bcc  CopyDataInit
+  ldr  r2, =_sbss
+  b  LoopFillZerobss
+/* Zero fill the bss segment. */  
+FillZerobss:
+  movs  r3, #0
+  str  r3, [r2], #4
+    
+LoopFillZerobss:
+  ldr  r3, = _ebss
+  cmp  r2, r3
+  bcc  FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit   
+/* Call static constructors */
+  //bl __libc_init_array
+/* Call the application's entry point.*/
+  //bl  main
+  // Calling the crt0 'cold-start' entry point. There __libc_init_array is called
+  // and when existing hardware_init_hook() and software_init_hook() before 
+  // starting main(). software_init_hook() is available and has to be called due 
+  // to initializsation when using rtos.
+  bl _start
+  bx  lr    
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an 
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None     
+ * @retval None       
+*/
+    .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+* 
+*******************************************************************************/
+   .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+   
+   
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  
+  /* External Interrupts */
+  .word     WWDG_IRQHandler                   /* Window WatchDog              */                                        
+  .word     PVD_AVD_IRQHandler                /* PVD/AVD through EXTI Line detection */                        
+  .word     TAMP_STAMP_IRQHandler             /* Tamper and TimeStamps through the EXTI line */            
+  .word     RTC_WKUP_IRQHandler               /* RTC Wakeup through the EXTI line */                      
+  .word     FLASH_IRQHandler                  /* FLASH                        */                                          
+  .word     RCC_IRQHandler                    /* RCC                          */                                            
+  .word     EXTI0_IRQHandler                  /* EXTI Line0                   */                        
+  .word     EXTI1_IRQHandler                  /* EXTI Line1                   */                          
+  .word     EXTI2_IRQHandler                  /* EXTI Line2                   */                          
+  .word     EXTI3_IRQHandler                  /* EXTI Line3                   */                          
+  .word     EXTI4_IRQHandler                  /* EXTI Line4                   */                          
+  .word     DMA1_Stream0_IRQHandler           /* DMA1 Stream 0                */                  
+  .word     DMA1_Stream1_IRQHandler           /* DMA1 Stream 1                */                   
+  .word     DMA1_Stream2_IRQHandler           /* DMA1 Stream 2                */                   
+  .word     DMA1_Stream3_IRQHandler           /* DMA1 Stream 3                */                   
+  .word     DMA1_Stream4_IRQHandler           /* DMA1 Stream 4                */                   
+  .word     DMA1_Stream5_IRQHandler           /* DMA1 Stream 5                */                   
+  .word     DMA1_Stream6_IRQHandler           /* DMA1 Stream 6                */                   
+  .word     ADC_IRQHandler                    /* ADC1, ADC2 and ADC3s         */                   
+  .word     FDCAN1_IT0_IRQHandler             /* FDCAN1 interrupt line 0      */                    
+  .word     FDCAN2_IT0_IRQHandler             /* FDCAN2 interrupt line 0      */                    
+  .word     FDCAN1_IT1_IRQHandler             /* FDCAN1 interrupt line 1      */                    
+  .word     FDCAN2_IT1_IRQHandler             /* FDCAN2 interrupt line 1      */                    
+  .word     EXTI9_5_IRQHandler                /* External Line[9:5]s          */                          
+  .word     TIM1_BRK_IRQHandler               /* TIM1 Break interrupt         */         
+  .word     TIM1_UP_IRQHandler                /* TIM1 Update interrupt        */         
+  .word     TIM1_TRG_COM_IRQHandler           /* TIM1 Trigger and Commutation interrupt */
+  .word     TIM1_CC_IRQHandler                /* TIM1 Capture Compare         */                          
+  .word     TIM2_IRQHandler                   /* TIM2                         */                   
+  .word     TIM3_IRQHandler                   /* TIM3                         */                   
+  .word     TIM4_IRQHandler                   /* TIM4                         */                   
+  .word     I2C1_EV_IRQHandler                /* I2C1 Event                   */                          
+  .word     I2C1_ER_IRQHandler                /* I2C1 Error                   */                          
+  .word     I2C2_EV_IRQHandler                /* I2C2 Event                   */                          
+  .word     I2C2_ER_IRQHandler                /* I2C2 Error                   */                            
+  .word     SPI1_IRQHandler                   /* SPI1                         */                   
+  .word     SPI2_IRQHandler                   /* SPI2                         */                   
+  .word     USART1_IRQHandler                 /* USART1                       */                   
+  .word     USART2_IRQHandler                 /* USART2                       */                   
+  .word     USART3_IRQHandler                 /* USART3                       */                   
+  .word     EXTI15_10_IRQHandler              /* External Line[15:10]s        */                          
+  .word     RTC_Alarm_IRQHandler              /* RTC Alarm (A and B) through EXTI Line */                 
+  .word     0                                 /* Reserved                     */                       
+  .word     TIM8_BRK_TIM12_IRQHandler         /* TIM8 Break and TIM12         */         
+  .word     TIM8_UP_TIM13_IRQHandler          /* TIM8 Update and TIM13        */         
+  .word     TIM8_TRG_COM_TIM14_IRQHandler     /* TIM8 Trigger and Commutation and TIM14 */
+  .word     TIM8_CC_IRQHandler                /* TIM8 Capture Compare         */                          
+  .word     DMA1_Stream7_IRQHandler           /* DMA1 Stream7                 */                          
+  .word     FMC_IRQHandler                    /* FMC                          */                   
+  .word     SDMMC1_IRQHandler                 /* SDMMC1                       */                   
+  .word     TIM5_IRQHandler                   /* TIM5                         */                   
+  .word     SPI3_IRQHandler                   /* SPI3                         */                   
+  .word     UART4_IRQHandler                  /* UART4                        */                   
+  .word     UART5_IRQHandler                  /* UART5                        */                   
+  .word     TIM6_DAC_IRQHandler               /* TIM6 and DAC1&2 underrun errors */                   
+  .word     TIM7_IRQHandler                   /* TIM7                         */
+  .word     DMA2_Stream0_IRQHandler           /* DMA2 Stream 0                */                   
+  .word     DMA2_Stream1_IRQHandler           /* DMA2 Stream 1                */                   
+  .word     DMA2_Stream2_IRQHandler           /* DMA2 Stream 2                */                   
+  .word     DMA2_Stream3_IRQHandler           /* DMA2 Stream 3                */                   
+  .word     DMA2_Stream4_IRQHandler           /* DMA2 Stream 4                */                   
+  .word     ETH_IRQHandler                    /* Ethernet                     */                   
+  .word     ETH_WKUP_IRQHandler               /* Ethernet Wakeup through EXTI line */                     
+  .word     FDCAN_CAL_IRQHandler              /* FDCAN calibration unit interrupt*/                                               
+  .word     CM7_SEV_IRQHandler                /* CM7 Send event interrupt for CM4*/                          
+  .word     CM4_SEV_IRQHandler                /* CM4 Send event interrupt for CM7*/                       
+  .word     0                                 /* Reserved                     */                           
+  .word     0                                 /* Reserved                     */                  
+  .word     DMA2_Stream5_IRQHandler           /* DMA2 Stream 5                */                   
+  .word     DMA2_Stream6_IRQHandler           /* DMA2 Stream 6                */                   
+  .word     DMA2_Stream7_IRQHandler           /* DMA2 Stream 7                */                   
+  .word     USART6_IRQHandler                 /* USART6                       */                    
+  .word     I2C3_EV_IRQHandler                /* I2C3 event                   */                          
+  .word     I2C3_ER_IRQHandler                /* I2C3 error                   */                          
+  .word     OTG_HS_EP1_OUT_IRQHandler         /* USB OTG HS End Point 1 Out   */                   
+  .word     OTG_HS_EP1_IN_IRQHandler          /* USB OTG HS End Point 1 In    */                   
+  .word     OTG_HS_WKUP_IRQHandler            /* USB OTG HS Wakeup through EXTI */                         
+  .word     OTG_HS_IRQHandler                 /* USB OTG HS                   */                   
+  .word     DCMI_IRQHandler                   /* DCMI                         */                   
+  .word     0                                 /* Reserved                     */                   
+  .word     RNG_IRQHandler                    /* Rng                          */
+  .word     FPU_IRQHandler                    /* FPU                          */
+  .word     UART7_IRQHandler                  /* UART7                        */      
+  .word     UART8_IRQHandler                  /* UART8                        */
+  .word     SPI4_IRQHandler                   /* SPI4                         */
+  .word     SPI5_IRQHandler                   /* SPI5                         */
+  .word     SPI6_IRQHandler                   /* SPI6                         */
+  .word     SAI1_IRQHandler                   /* SAI1                         */
+  .word     LTDC_IRQHandler                   /* LTDC                         */
+  .word     LTDC_ER_IRQHandler                /* LTDC error                   */
+  .word     DMA2D_IRQHandler                  /* DMA2D                        */
+  .word     SAI2_IRQHandler                   /* SAI2                         */
+  .word     QUADSPI_IRQHandler                /* QUADSPI                      */
+  .word     LPTIM1_IRQHandler                 /* LPTIM1                       */
+  .word     CEC_IRQHandler                    /* HDMI_CEC                     */
+  .word     I2C4_EV_IRQHandler                /* I2C4 Event                   */
+  .word     I2C4_ER_IRQHandler                /* I2C4 Error                   */
+  .word     SPDIF_RX_IRQHandler               /* SPDIF_RX                     */ 
+  .word     OTG_FS_EP1_OUT_IRQHandler         /* USB OTG FS End Point 1 Out   */   
+  .word     OTG_FS_EP1_IN_IRQHandler          /* USB OTG FS End Point 1 In    */   
+  .word     OTG_FS_WKUP_IRQHandler            /* USB OTG FS Wakeup through EXTI */  
+  .word     OTG_FS_IRQHandler                 /* USB OTG FS                   */
+  .word     DMAMUX1_OVR_IRQHandler            /* DMAMUX1 Overrun interrupt    */  
+  .word     HRTIM1_Master_IRQHandler          /* HRTIM Master Timer global Interrupt */
+  .word     HRTIM1_TIMA_IRQHandler            /* HRTIM Timer A global Interrupt */  
+  .word     HRTIM1_TIMB_IRQHandler            /* HRTIM Timer B global Interrupt */  
+  .word     HRTIM1_TIMC_IRQHandler            /* HRTIM Timer C global Interrupt */  
+  .word     HRTIM1_TIMD_IRQHandler            /* HRTIM Timer D global Interrupt */  
+  .word     HRTIM1_TIME_IRQHandler            /* HRTIM Timer E global Interrupt */  
+  .word     HRTIM1_FLT_IRQHandler             /* HRTIM Fault global Interrupt   */ 
+  .word     DFSDM1_FLT0_IRQHandler            /* DFSDM Filter0 Interrupt        */
+  .word     DFSDM1_FLT1_IRQHandler            /* DFSDM Filter1 Interrupt        */     
+  .word     DFSDM1_FLT2_IRQHandler            /* DFSDM Filter2 Interrupt        */    
+  .word     DFSDM1_FLT3_IRQHandler            /* DFSDM Filter3 Interrupt        */   
+  .word     SAI3_IRQHandler                   /* SAI3 global Interrupt          */   
+  .word     SWPMI1_IRQHandler                 /* Serial Wire Interface 1 global interrupt */
+  .word     TIM15_IRQHandler                  /* TIM15 global Interrupt      */        
+  .word     TIM16_IRQHandler                  /* TIM16 global Interrupt      */      
+  .word     TIM17_IRQHandler                  /* TIM17 global Interrupt      */      
+  .word     MDIOS_WKUP_IRQHandler             /* MDIOS Wakeup  Interrupt     */     
+  .word     MDIOS_IRQHandler                  /* MDIOS global Interrupt      */    
+  .word     JPEG_IRQHandler                   /* JPEG global Interrupt       */    
+  .word     MDMA_IRQHandler                   /* MDMA global Interrupt       */    
+  .word     DSI_IRQHandler                    /* DSI global Interrupt        */    
+  .word     SDMMC2_IRQHandler                 /* SDMMC2 global Interrupt     */    
+  .word     HSEM1_IRQHandler                  /* HSEM1 global Interrupt      */    
+  .word     HSEM2_IRQHandler                  /* HSEM2 global Interrupt      */    
+  .word     ADC3_IRQHandler                   /* ADC3 global Interrupt       */    
+  .word     DMAMUX2_OVR_IRQHandler            /* DMAMUX Overrun interrupt    */    
+  .word     BDMA_Channel0_IRQHandler          /* BDMA Channel 0 global Interrupt */
+  .word     BDMA_Channel1_IRQHandler          /* BDMA Channel 1 global Interrupt */ 
+  .word     BDMA_Channel2_IRQHandler          /* BDMA Channel 2 global Interrupt */ 
+  .word     BDMA_Channel3_IRQHandler          /* BDMA Channel 3 global Interrupt */ 
+  .word     BDMA_Channel4_IRQHandler          /* BDMA Channel 4 global Interrupt */ 
+  .word     BDMA_Channel5_IRQHandler          /* BDMA Channel 5 global Interrupt */ 
+  .word     BDMA_Channel6_IRQHandler          /* BDMA Channel 6 global Interrupt */ 
+  .word     BDMA_Channel7_IRQHandler          /* BDMA Channel 7 global Interrupt */ 
+  .word     COMP1_IRQHandler                  /* COMP1 global Interrupt     */          
+  .word     LPTIM2_IRQHandler                 /* LP TIM2 global interrupt   */      
+  .word     LPTIM3_IRQHandler                 /* LP TIM3 global interrupt   */     
+  .word     LPTIM4_IRQHandler                 /* LP TIM4 global interrupt   */     
+  .word     LPTIM5_IRQHandler                 /* LP TIM5 global interrupt   */     
+  .word     LPUART1_IRQHandler                /* LP UART1 interrupt         */     
+  .word     WWDG_RST_IRQHandler               /* Window Watchdog reset interrupt (exti_d2_wwdg_it, exti_d1_wwdg_it)*/     
+  .word     CRS_IRQHandler                    /* Clock Recovery Global Interrupt */ 
+  .word     ECC_IRQHandler                    /* ECC diagnostic Global Interrupt */     
+  .word     SAI4_IRQHandler                   /* SAI4 global interrupt      */      
+  .word     0                                 /* Reserved                   */      
+  .word     HOLD_CORE_IRQHandler              /* Hold core interrupt        */      
+  .word     WAKEUP_PIN_IRQHandler             /* Interrupt for all 6 wake-up pins */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler. 
+* As they are weak aliases, any function with the same name will override 
+* this definition.
+* 
+*******************************************************************************/
+   .weak      NMI_Handler
+   .thumb_set NMI_Handler,Default_Handler
+  
+   .weak      HardFault_Handler
+   .thumb_set HardFault_Handler,Default_Handler
+  
+   .weak      MemManage_Handler
+   .thumb_set MemManage_Handler,Default_Handler
+  
+   .weak      BusFault_Handler
+   .thumb_set BusFault_Handler,Default_Handler
+
+   .weak      UsageFault_Handler
+   .thumb_set UsageFault_Handler,Default_Handler
+
+   .weak      SVC_Handler
+   .thumb_set SVC_Handler,Default_Handler
+
+   .weak      DebugMon_Handler
+   .thumb_set DebugMon_Handler,Default_Handler
+
+   .weak      PendSV_Handler
+   .thumb_set PendSV_Handler,Default_Handler
+
+   .weak      SysTick_Handler
+   .thumb_set SysTick_Handler,Default_Handler              
+  
+   .weak      WWDG_IRQHandler                   
+   .thumb_set WWDG_IRQHandler,Default_Handler      
+                  
+   .weak      PVD_AVD_IRQHandler      
+   .thumb_set PVD_AVD_IRQHandler,Default_Handler
+               
+   .weak      TAMP_STAMP_IRQHandler            
+   .thumb_set TAMP_STAMP_IRQHandler,Default_Handler
+            
+   .weak      RTC_WKUP_IRQHandler                  
+   .thumb_set RTC_WKUP_IRQHandler,Default_Handler
+            
+   .weak      FLASH_IRQHandler         
+   .thumb_set FLASH_IRQHandler,Default_Handler
+                  
+   .weak      RCC_IRQHandler      
+   .thumb_set RCC_IRQHandler,Default_Handler
+                  
+   .weak      EXTI0_IRQHandler         
+   .thumb_set EXTI0_IRQHandler,Default_Handler
+                  
+   .weak      EXTI1_IRQHandler         
+   .thumb_set EXTI1_IRQHandler,Default_Handler
+                     
+   .weak      EXTI2_IRQHandler         
+   .thumb_set EXTI2_IRQHandler,Default_Handler 
+                 
+   .weak      EXTI3_IRQHandler         
+   .thumb_set EXTI3_IRQHandler,Default_Handler
+                        
+   .weak      EXTI4_IRQHandler         
+   .thumb_set EXTI4_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream0_IRQHandler               
+   .thumb_set DMA1_Stream0_IRQHandler,Default_Handler
+         
+   .weak      DMA1_Stream1_IRQHandler               
+   .thumb_set DMA1_Stream1_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream2_IRQHandler               
+   .thumb_set DMA1_Stream2_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream3_IRQHandler               
+   .thumb_set DMA1_Stream3_IRQHandler,Default_Handler 
+                 
+   .weak      DMA1_Stream4_IRQHandler              
+   .thumb_set DMA1_Stream4_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream5_IRQHandler               
+   .thumb_set DMA1_Stream5_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream6_IRQHandler               
+   .thumb_set DMA1_Stream6_IRQHandler,Default_Handler
+                  
+   .weak      ADC_IRQHandler      
+   .thumb_set ADC_IRQHandler,Default_Handler
+               
+   .weak      FDCAN1_IT0_IRQHandler   
+   .thumb_set FDCAN1_IT0_IRQHandler,Default_Handler
+            
+   .weak      FDCAN2_IT0_IRQHandler                  
+   .thumb_set FDCAN2_IT0_IRQHandler,Default_Handler
+                           
+   .weak      FDCAN1_IT1_IRQHandler                  
+   .thumb_set FDCAN1_IT1_IRQHandler,Default_Handler
+            
+   .weak      FDCAN2_IT1_IRQHandler                  
+   .thumb_set FDCAN2_IT1_IRQHandler,Default_Handler
+            
+   .weak      EXTI9_5_IRQHandler   
+   .thumb_set EXTI9_5_IRQHandler,Default_Handler
+            
+   .weak      TIM1_BRK_IRQHandler            
+   .thumb_set TIM1_BRK_IRQHandler,Default_Handler
+            
+   .weak      TIM1_UP_IRQHandler            
+   .thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+   .weak      TIM1_TRG_COM_IRQHandler      
+   .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+      
+   .weak      TIM1_CC_IRQHandler   
+   .thumb_set TIM1_CC_IRQHandler,Default_Handler
+                  
+   .weak      TIM2_IRQHandler            
+   .thumb_set TIM2_IRQHandler,Default_Handler
+                  
+   .weak      TIM3_IRQHandler            
+   .thumb_set TIM3_IRQHandler,Default_Handler
+                  
+   .weak      TIM4_IRQHandler            
+   .thumb_set TIM4_IRQHandler,Default_Handler
+                  
+   .weak      I2C1_EV_IRQHandler   
+   .thumb_set I2C1_EV_IRQHandler,Default_Handler
+                     
+   .weak      I2C1_ER_IRQHandler   
+   .thumb_set I2C1_ER_IRQHandler,Default_Handler
+                     
+   .weak      I2C2_EV_IRQHandler   
+   .thumb_set I2C2_EV_IRQHandler,Default_Handler
+                  
+   .weak      I2C2_ER_IRQHandler   
+   .thumb_set I2C2_ER_IRQHandler,Default_Handler
+                           
+   .weak      SPI1_IRQHandler            
+   .thumb_set SPI1_IRQHandler,Default_Handler
+                        
+   .weak      SPI2_IRQHandler            
+   .thumb_set SPI2_IRQHandler,Default_Handler
+                  
+   .weak      USART1_IRQHandler      
+   .thumb_set USART1_IRQHandler,Default_Handler
+                     
+   .weak      USART2_IRQHandler      
+   .thumb_set USART2_IRQHandler,Default_Handler
+                     
+   .weak      USART3_IRQHandler      
+   .thumb_set USART3_IRQHandler,Default_Handler
+                  
+   .weak      EXTI15_10_IRQHandler               
+   .thumb_set EXTI15_10_IRQHandler,Default_Handler
+               
+   .weak      RTC_Alarm_IRQHandler               
+   .thumb_set RTC_Alarm_IRQHandler,Default_Handler
+            
+   .weak      TIM8_BRK_TIM12_IRQHandler         
+   .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler
+         
+   .weak      TIM8_UP_TIM13_IRQHandler            
+   .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler
+         
+   .weak      TIM8_TRG_COM_TIM14_IRQHandler      
+   .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler
+      
+   .weak      TIM8_CC_IRQHandler   
+   .thumb_set TIM8_CC_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream7_IRQHandler               
+   .thumb_set DMA1_Stream7_IRQHandler,Default_Handler
+                     
+   .weak      FMC_IRQHandler            
+   .thumb_set FMC_IRQHandler,Default_Handler
+                     
+   .weak      SDMMC1_IRQHandler            
+   .thumb_set SDMMC1_IRQHandler,Default_Handler
+                     
+   .weak      TIM5_IRQHandler            
+   .thumb_set TIM5_IRQHandler,Default_Handler
+                     
+   .weak      SPI3_IRQHandler            
+   .thumb_set SPI3_IRQHandler,Default_Handler
+                     
+   .weak      UART4_IRQHandler         
+   .thumb_set UART4_IRQHandler,Default_Handler
+                  
+   .weak      UART5_IRQHandler         
+   .thumb_set UART5_IRQHandler,Default_Handler
+                  
+   .weak      TIM6_DAC_IRQHandler                  
+   .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+               
+   .weak      TIM7_IRQHandler            
+   .thumb_set TIM7_IRQHandler,Default_Handler
+         
+   .weak      DMA2_Stream0_IRQHandler               
+   .thumb_set DMA2_Stream0_IRQHandler,Default_Handler
+               
+   .weak      DMA2_Stream1_IRQHandler               
+   .thumb_set DMA2_Stream1_IRQHandler,Default_Handler
+                  
+   .weak      DMA2_Stream2_IRQHandler               
+   .thumb_set DMA2_Stream2_IRQHandler,Default_Handler
+            
+   .weak      DMA2_Stream3_IRQHandler               
+   .thumb_set DMA2_Stream3_IRQHandler,Default_Handler
+            
+   .weak      DMA2_Stream4_IRQHandler               
+   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler
+    
+   .weak      ETH_IRQHandler   
+   .thumb_set ETH_IRQHandler,Default_Handler
+   
+   .weak      ETH_WKUP_IRQHandler   
+   .thumb_set ETH_WKUP_IRQHandler,Default_Handler
+
+   .weak      FDCAN_CAL_IRQHandler   
+   .thumb_set FDCAN_CAL_IRQHandler,Default_Handler   
+
+   .weak      CM7_SEV_IRQHandler   
+   .thumb_set CM7_SEV_IRQHandler,Default_Handler   
+
+   .weak      CM4_SEV_IRQHandler   
+   .thumb_set CM4_SEV_IRQHandler,Default_Handler   
+                                                                  
+   .weak      DMA2_Stream5_IRQHandler               
+   .thumb_set DMA2_Stream5_IRQHandler,Default_Handler
+                  
+   .weak      DMA2_Stream6_IRQHandler               
+   .thumb_set DMA2_Stream6_IRQHandler,Default_Handler
+                  
+   .weak      DMA2_Stream7_IRQHandler               
+   .thumb_set DMA2_Stream7_IRQHandler,Default_Handler
+                  
+   .weak      USART6_IRQHandler      
+   .thumb_set USART6_IRQHandler,Default_Handler
+                        
+   .weak      I2C3_EV_IRQHandler   
+   .thumb_set I2C3_EV_IRQHandler,Default_Handler
+                        
+   .weak      I2C3_ER_IRQHandler   
+   .thumb_set I2C3_ER_IRQHandler,Default_Handler
+                        
+   .weak      OTG_HS_EP1_OUT_IRQHandler         
+   .thumb_set OTG_HS_EP1_OUT_IRQHandler,Default_Handler
+               
+   .weak      OTG_HS_EP1_IN_IRQHandler            
+   .thumb_set OTG_HS_EP1_IN_IRQHandler,Default_Handler
+               
+   .weak      OTG_HS_WKUP_IRQHandler         
+   .thumb_set OTG_HS_WKUP_IRQHandler,Default_Handler
+            
+   .weak      OTG_HS_IRQHandler      
+   .thumb_set OTG_HS_IRQHandler,Default_Handler
+                  
+   .weak      DCMI_IRQHandler            
+   .thumb_set DCMI_IRQHandler,Default_Handler
+
+   .weak      RNG_IRQHandler            
+   .thumb_set RNG_IRQHandler,Default_Handler   
+
+   .weak      FPU_IRQHandler                  
+   .thumb_set FPU_IRQHandler,Default_Handler
+
+   .weak      UART7_IRQHandler                  
+   .thumb_set UART7_IRQHandler,Default_Handler
+
+   .weak      UART8_IRQHandler                  
+   .thumb_set UART8_IRQHandler,Default_Handler   
+
+   .weak      SPI4_IRQHandler            
+   .thumb_set SPI4_IRQHandler,Default_Handler
+   
+   .weak      SPI5_IRQHandler            
+   .thumb_set SPI5_IRQHandler,Default_Handler
+
+   .weak      SPI6_IRQHandler            
+   .thumb_set SPI6_IRQHandler,Default_Handler   
+
+   .weak      SAI1_IRQHandler            
+   .thumb_set SAI1_IRQHandler,Default_Handler
+   
+   .weak      LTDC_IRQHandler            
+   .thumb_set LTDC_IRQHandler,Default_Handler
+
+   .weak      LTDC_ER_IRQHandler            
+   .thumb_set LTDC_ER_IRQHandler,Default_Handler
+
+   .weak      DMA2D_IRQHandler            
+   .thumb_set DMA2D_IRQHandler,Default_Handler   
+
+   .weak      SAI2_IRQHandler            
+   .thumb_set SAI2_IRQHandler,Default_Handler
+   
+   .weak      QUADSPI_IRQHandler            
+   .thumb_set QUADSPI_IRQHandler,Default_Handler
+ 
+   .weak      LPTIM1_IRQHandler            
+   .thumb_set LPTIM1_IRQHandler,Default_Handler
+
+   .weak      CEC_IRQHandler            
+   .thumb_set CEC_IRQHandler,Default_Handler
+   
+   .weak      I2C4_EV_IRQHandler            
+   .thumb_set I2C4_EV_IRQHandler,Default_Handler 
+ 
+   .weak      I2C4_ER_IRQHandler            
+   .thumb_set I2C4_ER_IRQHandler,Default_Handler
+   
+   .weak      SPDIF_RX_IRQHandler            
+   .thumb_set SPDIF_RX_IRQHandler,Default_Handler
+
+   .weak      OTG_FS_EP1_OUT_IRQHandler            
+   .thumb_set OTG_FS_EP1_OUT_IRQHandler,Default_Handler
+   
+   .weak      OTG_FS_EP1_IN_IRQHandler            
+   .thumb_set OTG_FS_EP1_IN_IRQHandler,Default_Handler 
+
+   .weak      OTG_FS_WKUP_IRQHandler            
+   .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler
+
+   .weak      OTG_FS_IRQHandler            
+   .thumb_set OTG_FS_IRQHandler,Default_Handler
+   
+   .weak      DMAMUX1_OVR_IRQHandler            
+   .thumb_set DMAMUX1_OVR_IRQHandler,Default_Handler
+
+   .weak      HRTIM1_Master_IRQHandler            
+   .thumb_set HRTIM1_Master_IRQHandler,Default_Handler
+   
+   .weak      HRTIM1_TIMA_IRQHandler            
+   .thumb_set HRTIM1_TIMA_IRQHandler,Default_Handler
+
+   .weak      HRTIM1_TIMB_IRQHandler            
+   .thumb_set HRTIM1_TIMB_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_TIMC_IRQHandler            
+   .thumb_set HRTIM1_TIMC_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_TIMD_IRQHandler            
+   .thumb_set HRTIM1_TIMD_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_TIME_IRQHandler            
+   .thumb_set HRTIM1_TIME_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_FLT_IRQHandler            
+   .thumb_set HRTIM1_FLT_IRQHandler,Default_Handler
+
+   .weak      DFSDM1_FLT0_IRQHandler            
+   .thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler  
+
+   .weak      DFSDM1_FLT1_IRQHandler            
+   .thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler 
+
+   .weak      DFSDM1_FLT2_IRQHandler            
+   .thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler 
+
+   .weak      DFSDM1_FLT3_IRQHandler            
+   .thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler    
+ 
+   .weak      SAI3_IRQHandler            
+   .thumb_set SAI3_IRQHandler,Default_Handler
+   
+   .weak      SWPMI1_IRQHandler            
+   .thumb_set SWPMI1_IRQHandler,Default_Handler
+
+   .weak      TIM15_IRQHandler            
+   .thumb_set TIM15_IRQHandler,Default_Handler 
+
+   .weak      TIM16_IRQHandler            
+   .thumb_set TIM16_IRQHandler,Default_Handler 
+
+   .weak      TIM17_IRQHandler            
+   .thumb_set TIM17_IRQHandler,Default_Handler 
+
+   .weak      MDIOS_WKUP_IRQHandler            
+   .thumb_set MDIOS_WKUP_IRQHandler,Default_Handler 
+
+   .weak      MDIOS_IRQHandler            
+   .thumb_set MDIOS_IRQHandler,Default_Handler 
+
+   .weak      JPEG_IRQHandler            
+   .thumb_set JPEG_IRQHandler,Default_Handler 
+
+   .weak      MDMA_IRQHandler            
+   .thumb_set MDMA_IRQHandler,Default_Handler 
+
+   .weak      DSI_IRQHandler            
+   .thumb_set DSI_IRQHandler,Default_Handler 
+
+   .weak      SDMMC2_IRQHandler            
+   .thumb_set SDMMC2_IRQHandler,Default_Handler 
+   
+   .weak      HSEM1_IRQHandler            
+   .thumb_set HSEM1_IRQHandler,Default_Handler
+
+   .weak      HSEM2_IRQHandler            
+   .thumb_set HSEM2_IRQHandler,Default_Handler
+
+   .weak      ADC3_IRQHandler            
+   .thumb_set ADC3_IRQHandler,Default_Handler 
+
+   .weak      DMAMUX2_OVR_IRQHandler            
+   .thumb_set DMAMUX2_OVR_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel0_IRQHandler            
+   .thumb_set BDMA_Channel0_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel1_IRQHandler            
+   .thumb_set BDMA_Channel1_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel2_IRQHandler            
+   .thumb_set BDMA_Channel2_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel3_IRQHandler            
+   .thumb_set BDMA_Channel3_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel4_IRQHandler            
+   .thumb_set BDMA_Channel4_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel5_IRQHandler            
+   .thumb_set BDMA_Channel5_IRQHandler,Default_Handler    
+
+   .weak      BDMA_Channel6_IRQHandler            
+   .thumb_set BDMA_Channel6_IRQHandler,Default_Handler
+
+   .weak      BDMA_Channel7_IRQHandler            
+   .thumb_set BDMA_Channel7_IRQHandler,Default_Handler 
+
+   .weak      COMP1_IRQHandler            
+   .thumb_set COMP1_IRQHandler,Default_Handler 
+
+   .weak      LPTIM2_IRQHandler            
+   .thumb_set LPTIM2_IRQHandler,Default_Handler 
+
+   .weak      LPTIM3_IRQHandler            
+   .thumb_set LPTIM3_IRQHandler,Default_Handler 
+
+   .weak      LPTIM4_IRQHandler            
+   .thumb_set LPTIM4_IRQHandler,Default_Handler 
+
+   .weak      LPTIM5_IRQHandler            
+   .thumb_set LPTIM5_IRQHandler,Default_Handler 
+
+   .weak      LPUART1_IRQHandler            
+   .thumb_set LPUART1_IRQHandler,Default_Handler 
+
+   .weak      WWDG_RST_IRQHandler            
+   .thumb_set WWDG_RST_IRQHandler,Default_Handler 
+
+   .weak      CRS_IRQHandler            
+   .thumb_set CRS_IRQHandler,Default_Handler 
+
+   .weak      ECC_IRQHandler            
+   .thumb_set ECC_IRQHandler,Default_Handler
+
+   .weak      SAI4_IRQHandler            
+   .thumb_set SAI4_IRQHandler,Default_Handler 
+
+   .weak      HOLD_CORE_IRQHandler            
+   .thumb_set HOLD_CORE_IRQHandler,Default_Handler 
+
+   .weak      WAKEUP_PIN_IRQHandler            
+   .thumb_set WAKEUP_PIN_IRQHandler,Default_Handler 
+   
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/        
+ 
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/STM32H747xI.ld b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/STM32H747xI.ld
new file mode 100644
index 0000000000..62fb0bdba2
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/STM32H747xI.ld
@@ -0,0 +1,220 @@
+/* Linker script to configure memory regions. */
+
+#if !defined(MBED_APP_START)
+  #define MBED_APP_START 0x08000000
+#endif
+
+#if !defined(MBED_APP_SIZE)
+  #define MBED_APP_SIZE 1024K
+#endif
+
+#if !defined(RAM_START)
+  #define RAM_START 0x24000000
+#endif
+
+#if !defined(RAM_SIZE)
+  #define RAM_SIZE 512K
+#endif
+
+#if !defined(MBED_BOOT_STACK_SIZE)
+    #define MBED_BOOT_STACK_SIZE 0x400
+#endif
+
+STACK_SIZE = MBED_BOOT_STACK_SIZE;
+
+M_CRASH_DATA_RAM_SIZE = 0x100;
+
+/* 0x298 bytes is the size of vectors - see cmsis_nvic.h */
+
+MEMORY
+{
+  ITCMRAM (xrw)                 : ORIGIN = 0x00000000, LENGTH = 64K
+  DTCMRAM (xrw)                 : ORIGIN = 0x20000000, LENGTH = 128K
+  RAM (xrw)                     : ORIGIN = RAM_START + 0x298, LENGTH = RAM_SIZE - 0x298
+  RAM_D2 (xrw)                  : ORIGIN = 0x30000000, LENGTH = 288K
+  OPENAMP_RSC_TAB (rwx)         : ORIGIN = 0x38000000, LENGTH = 1K
+  OPEN_AMP_SHMEM (rwx)          : ORIGIN = 0x38000400, LENGTH = 63K
+  FLASH (rx)                    : ORIGIN = MBED_APP_START, LENGTH = MBED_APP_SIZE
+}
+ __OPENAMP_region_start__  = ORIGIN(OPEN_AMP_SHMEM);
+ __OPENAMP_region_end__ = ORIGIN(OPEN_AMP_SHMEM) + LENGTH(OPEN_AMP_SHMEM);
+
+/* Linker script to place sections and symbol values. Should be used together
+ * with other linker script that defines memory regions FLASH and RAM.
+ * It references following symbols, which must be defined in code:
+ *   Reset_Handler : Entry of reset handler
+ * 
+ * It defines following symbols, which code can use without definition:
+ *   __exidx_start
+ *   __exidx_end
+ *   __etext
+ *   __data_start__
+ *   __preinit_array_start
+ *   __preinit_array_end
+ *   __init_array_start
+ *   __init_array_end
+ *   __fini_array_start
+ *   __fini_array_end
+ *   __data_end__
+ *   __bss_start__
+ *   __bss_end__
+ *   __end__
+ *   end
+ *   __HeapLimit
+ *   __StackLimit
+ *   __StackTop
+ *   __stack
+ *   _estack
+ */
+ENTRY(Reset_Handler)
+
+SECTIONS
+{
+    .text :
+    {
+        KEEP(*(.isr_vector))
+        *(.text*)
+        KEEP(*(.init))
+        KEEP(*(.fini))
+
+        /* .ctors */
+        *crtbegin.o(.ctors)
+        *crtbegin?.o(.ctors)
+        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
+        *(SORT(.ctors.*))
+        *(.ctors)
+
+        /* .dtors */
+        *crtbegin.o(.dtors)
+        *crtbegin?.o(.dtors)
+        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
+        *(SORT(.dtors.*))
+        *(.dtors)
+
+        *(.rodata*)
+
+        KEEP(*(.eh_frame*))
+    } > FLASH
+
+    .ARM.extab :
+    {
+        *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > FLASH
+
+    __exidx_start = .;
+    .ARM.exidx :
+    {
+        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > FLASH
+    __exidx_end = .;
+
+    __etext = .;
+    _sidata = .;
+    
+    .crash_data_ram :
+    {
+        . = ALIGN(8);
+        __CRASH_DATA_RAM__ = .;
+        __CRASH_DATA_RAM_START__ = .; /* Create a global symbol at data start */
+        KEEP(*(.keep.crash_data_ram))
+        *(.m_crash_data_ram)     /* This is a user defined section */
+        . += M_CRASH_DATA_RAM_SIZE;
+        . = ALIGN(8);
+        __CRASH_DATA_RAM_END__ = .; /* Define a global symbol at data end */
+    } > RAM
+
+    .data : AT (__etext)
+    {
+        __data_start__ = .;
+        _sdata = .;
+        *(vtable)
+        *(.data*)
+
+        . = ALIGN(8);
+        /* preinit data */
+        PROVIDE_HIDDEN (__preinit_array_start = .);
+        KEEP(*(.preinit_array))
+        PROVIDE_HIDDEN (__preinit_array_end = .);
+
+        . = ALIGN(8);
+        /* init data */
+        PROVIDE_HIDDEN (__init_array_start = .);
+        KEEP(*(SORT(.init_array.*)))
+        KEEP(*(.init_array))
+        PROVIDE_HIDDEN (__init_array_end = .);
+
+
+        . = ALIGN(8);
+        /* finit data */
+        PROVIDE_HIDDEN (__fini_array_start = .);
+        KEEP(*(SORT(.fini_array.*)))
+        KEEP(*(.fini_array))
+        PROVIDE_HIDDEN (__fini_array_end = .);
+
+        KEEP(*(.jcr*))
+        . = ALIGN(8);
+        /* All data end */
+        __data_end__ = .;
+        _edata = .;
+
+    } > RAM
+
+    .bss :
+    {
+        . = ALIGN(8);
+        __bss_start__ = .;
+        _sbss = .;
+        *(.bss*)
+        *(COMMON)
+        . = ALIGN(8);
+        __bss_end__ = .;
+        _ebss = .;
+    } > RAM
+
+    .heap (COPY):
+    {
+        __end__ = .;
+        end = __end__;
+        *(.heap*)
+        . = ORIGIN(RAM) + LENGTH(RAM) - STACK_SIZE;
+        __HeapLimit = .;
+    } > RAM
+
+    .openamp_section (NOLOAD) : {
+        . = ABSOLUTE(0x38000000);
+        *(.resource_table)
+    } >OPENAMP_RSC_TAB  AT > FLASH
+
+    /* .stack_dummy section doesn't contains any symbols. It is only
+     * used for linker to calculate size of stack sections, and assign
+     * values to stack symbols later */
+    .stack_dummy (COPY):
+    {
+        *(.stack*)
+    } > RAM
+
+    /* Set stack top to end of RAM, and stack limit move down by
+     * size of stack_dummy section */
+    __StackTop = ORIGIN(RAM) + LENGTH(RAM);
+    _estack = __StackTop;
+    __StackLimit = __StackTop - STACK_SIZE;
+    PROVIDE(__stack = __StackTop);
+
+    /* Check if data + heap + stack exceeds RAM limit */
+    ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")
+
+    .lwip_sec (NOLOAD) : {
+        . = ABSOLUTE(0x30040000);
+        *(.RxDecripSection)
+
+        . = ABSOLUTE(0x30040100);
+        *(.TxDecripSection)
+
+        . = ABSOLUTE(0x30040400);
+        *(.RxArraySection)
+
+        . = ABSOLUTE(0x30044000);
+        *(.ethusbram)
+
+    } >RAM_D2 AT> FLASH
+}
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S
new file mode 100644
index 0000000000..671eecd963
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7_M7/TOOLCHAIN_GCC_ARM/startup_stm32h747xx.S
@@ -0,0 +1,787 @@
+/**
+  ******************************************************************************
+  * @file      startup_stm32h743xx.s
+  * @author    MCD Application Team
+  * @brief     STM32H743xx Devices vector table for GCC based toolchain. 
+  *            This module performs:
+  *                - Set the initial SP
+  *                - Set the initial PC == Reset_Handler,
+  *                - Set the vector table entries with the exceptions ISR address
+  *                - Branches to main in the C library (which eventually
+  *                  calls main()).
+  *            After Reset the Cortex-M processor is in Thread mode,
+  *            priority is Privileged, and the Stack is set to Main.
+  ******************************************************************************
+  * @attention
+  *
+  * <h2><center>&copy; COPYRIGHT 2017 STMicroelectronics</center></h2>
+  *
+  * Redistribution and use in source and binary forms, with or without modification,
+  * are permitted provided that the following conditions are met:
+  *   1. Redistributions of source code must retain the above copyright notice,
+  *      this list of conditions and the following disclaimer.
+  *   2. Redistributions in binary form must reproduce the above copyright notice,
+  *      this list of conditions and the following disclaimer in the documentation
+  *      and/or other materials provided with the distribution.
+  *   3. Neither the name of STMicroelectronics nor the names of its contributors
+  *      may be used to endorse or promote products derived from this software
+  *      without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+  *
+  ******************************************************************************
+  */
+    
+  .syntax unified
+  .cpu cortex-m7
+  .fpu softvfp
+  .thumb
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/* start address for the initialization values of the .data section. 
+defined in linker script */
+.word  _sidata
+/* start address for the .data section. defined in linker script */  
+.word  _sdata
+/* end address for the .data section. defined in linker script */
+.word  _edata
+/* start address for the .bss section. defined in linker script */
+.word  _sbss
+/* end address for the .bss section. defined in linker script */
+.word  _ebss
+/* stack used for SystemInit_ExtMemCtl; always internal RAM used */
+
+/**
+ * @brief  This is the code that gets called when the processor first
+ *          starts execution following a reset event. Only the absolutely
+ *          necessary set is performed, after which the application
+ *          supplied main() routine is called. 
+ * @param  None
+ * @retval : None
+*/
+
+    .section  .text.Reset_Handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:  
+  ldr   sp, =_estack      /* set stack pointer */
+
+/* Copy the data segment initializers from flash to SRAM */  
+  movs  r1, #0
+  b  LoopCopyDataInit
+
+CopyDataInit:
+  ldr  r3, =_sidata
+  ldr  r3, [r3, r1]
+  str  r3, [r0, r1]
+  adds  r1, r1, #4
+    
+LoopCopyDataInit:
+  ldr  r0, =_sdata
+  ldr  r3, =_edata
+  adds  r2, r0, r1
+  cmp  r2, r3
+  bcc  CopyDataInit
+  ldr  r2, =_sbss
+  b  LoopFillZerobss
+/* Zero fill the bss segment. */  
+FillZerobss:
+  movs  r3, #0
+  str  r3, [r2], #4
+    
+LoopFillZerobss:
+  ldr  r3, = _ebss
+  cmp  r2, r3
+  bcc  FillZerobss
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit   
+/* Call static constructors */
+  //bl __libc_init_array
+/* Call the application's entry point.*/
+  //bl  main
+  // Calling the crt0 'cold-start' entry point. There __libc_init_array is called
+  // and when existing hardware_init_hook() and software_init_hook() before 
+  // starting main(). software_init_hook() is available and has to be called due 
+  // to initializsation when using rtos.
+  bl _start
+  bx  lr    
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is the code that gets called when the processor receives an 
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None     
+ * @retval None       
+*/
+    .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+* 
+*******************************************************************************/
+   .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+   
+   
+g_pfnVectors:
+  .word  _estack
+  .word  Reset_Handler
+
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SVC_Handler
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Handler
+  .word  SysTick_Handler
+  
+  /* External Interrupts */
+  .word     WWDG_IRQHandler                   /* Window WatchDog              */                                        
+  .word     PVD_AVD_IRQHandler                /* PVD/AVD through EXTI Line detection */                        
+  .word     TAMP_STAMP_IRQHandler             /* Tamper and TimeStamps through the EXTI line */            
+  .word     RTC_WKUP_IRQHandler               /* RTC Wakeup through the EXTI line */                      
+  .word     FLASH_IRQHandler                  /* FLASH                        */                                          
+  .word     RCC_IRQHandler                    /* RCC                          */                                            
+  .word     EXTI0_IRQHandler                  /* EXTI Line0                   */                        
+  .word     EXTI1_IRQHandler                  /* EXTI Line1                   */                          
+  .word     EXTI2_IRQHandler                  /* EXTI Line2                   */                          
+  .word     EXTI3_IRQHandler                  /* EXTI Line3                   */                          
+  .word     EXTI4_IRQHandler                  /* EXTI Line4                   */                          
+  .word     DMA1_Stream0_IRQHandler           /* DMA1 Stream 0                */                  
+  .word     DMA1_Stream1_IRQHandler           /* DMA1 Stream 1                */                   
+  .word     DMA1_Stream2_IRQHandler           /* DMA1 Stream 2                */                   
+  .word     DMA1_Stream3_IRQHandler           /* DMA1 Stream 3                */                   
+  .word     DMA1_Stream4_IRQHandler           /* DMA1 Stream 4                */                   
+  .word     DMA1_Stream5_IRQHandler           /* DMA1 Stream 5                */                   
+  .word     DMA1_Stream6_IRQHandler           /* DMA1 Stream 6                */                   
+  .word     ADC_IRQHandler                    /* ADC1, ADC2 and ADC3s         */                   
+  .word     FDCAN1_IT0_IRQHandler             /* FDCAN1 interrupt line 0      */                    
+  .word     FDCAN2_IT0_IRQHandler             /* FDCAN2 interrupt line 0      */                    
+  .word     FDCAN1_IT1_IRQHandler             /* FDCAN1 interrupt line 1      */                    
+  .word     FDCAN2_IT1_IRQHandler             /* FDCAN2 interrupt line 1      */                    
+  .word     EXTI9_5_IRQHandler                /* External Line[9:5]s          */                          
+  .word     TIM1_BRK_IRQHandler               /* TIM1 Break interrupt         */         
+  .word     TIM1_UP_IRQHandler                /* TIM1 Update interrupt        */         
+  .word     TIM1_TRG_COM_IRQHandler           /* TIM1 Trigger and Commutation interrupt */
+  .word     TIM1_CC_IRQHandler                /* TIM1 Capture Compare         */                          
+  .word     TIM2_IRQHandler                   /* TIM2                         */                   
+  .word     TIM3_IRQHandler                   /* TIM3                         */                   
+  .word     TIM4_IRQHandler                   /* TIM4                         */                   
+  .word     I2C1_EV_IRQHandler                /* I2C1 Event                   */                          
+  .word     I2C1_ER_IRQHandler                /* I2C1 Error                   */                          
+  .word     I2C2_EV_IRQHandler                /* I2C2 Event                   */                          
+  .word     I2C2_ER_IRQHandler                /* I2C2 Error                   */                            
+  .word     SPI1_IRQHandler                   /* SPI1                         */                   
+  .word     SPI2_IRQHandler                   /* SPI2                         */                   
+  .word     USART1_IRQHandler                 /* USART1                       */                   
+  .word     USART2_IRQHandler                 /* USART2                       */                   
+  .word     USART3_IRQHandler                 /* USART3                       */                   
+  .word     EXTI15_10_IRQHandler              /* External Line[15:10]s        */                          
+  .word     RTC_Alarm_IRQHandler              /* RTC Alarm (A and B) through EXTI Line */                 
+  .word     0                                 /* Reserved                     */                       
+  .word     TIM8_BRK_TIM12_IRQHandler         /* TIM8 Break and TIM12         */         
+  .word     TIM8_UP_TIM13_IRQHandler          /* TIM8 Update and TIM13        */         
+  .word     TIM8_TRG_COM_TIM14_IRQHandler     /* TIM8 Trigger and Commutation and TIM14 */
+  .word     TIM8_CC_IRQHandler                /* TIM8 Capture Compare         */                          
+  .word     DMA1_Stream7_IRQHandler           /* DMA1 Stream7                 */                          
+  .word     FMC_IRQHandler                    /* FMC                          */                   
+  .word     SDMMC1_IRQHandler                 /* SDMMC1                       */                   
+  .word     TIM5_IRQHandler                   /* TIM5                         */                   
+  .word     SPI3_IRQHandler                   /* SPI3                         */                   
+  .word     UART4_IRQHandler                  /* UART4                        */                   
+  .word     UART5_IRQHandler                  /* UART5                        */                   
+  .word     TIM6_DAC_IRQHandler               /* TIM6 and DAC1&2 underrun errors */                   
+  .word     TIM7_IRQHandler                   /* TIM7                         */
+  .word     DMA2_Stream0_IRQHandler           /* DMA2 Stream 0                */                   
+  .word     DMA2_Stream1_IRQHandler           /* DMA2 Stream 1                */                   
+  .word     DMA2_Stream2_IRQHandler           /* DMA2 Stream 2                */                   
+  .word     DMA2_Stream3_IRQHandler           /* DMA2 Stream 3                */                   
+  .word     DMA2_Stream4_IRQHandler           /* DMA2 Stream 4                */                   
+  .word     ETH_IRQHandler                    /* Ethernet                     */                   
+  .word     ETH_WKUP_IRQHandler               /* Ethernet Wakeup through EXTI line */                     
+  .word     FDCAN_CAL_IRQHandler              /* FDCAN calibration unit interrupt*/                                               
+  .word     CM7_SEV_IRQHandler                /* CM7 Send event interrupt for CM4*/                          
+  .word     CM4_SEV_IRQHandler                /* CM4 Send event interrupt for CM7*/                       
+  .word     0                                 /* Reserved                     */                           
+  .word     0                                 /* Reserved                     */                  
+  .word     DMA2_Stream5_IRQHandler           /* DMA2 Stream 5                */                   
+  .word     DMA2_Stream6_IRQHandler           /* DMA2 Stream 6                */                   
+  .word     DMA2_Stream7_IRQHandler           /* DMA2 Stream 7                */                   
+  .word     USART6_IRQHandler                 /* USART6                       */                    
+  .word     I2C3_EV_IRQHandler                /* I2C3 event                   */                          
+  .word     I2C3_ER_IRQHandler                /* I2C3 error                   */                          
+  .word     OTG_HS_EP1_OUT_IRQHandler         /* USB OTG HS End Point 1 Out   */                   
+  .word     OTG_HS_EP1_IN_IRQHandler          /* USB OTG HS End Point 1 In    */                   
+  .word     OTG_HS_WKUP_IRQHandler            /* USB OTG HS Wakeup through EXTI */                         
+  .word     OTG_HS_IRQHandler                 /* USB OTG HS                   */                   
+  .word     DCMI_IRQHandler                   /* DCMI                         */                   
+  .word     0                                 /* Reserved                     */                   
+  .word     RNG_IRQHandler                    /* Rng                          */
+  .word     FPU_IRQHandler                    /* FPU                          */
+  .word     UART7_IRQHandler                  /* UART7                        */      
+  .word     UART8_IRQHandler                  /* UART8                        */
+  .word     SPI4_IRQHandler                   /* SPI4                         */
+  .word     SPI5_IRQHandler                   /* SPI5                         */
+  .word     SPI6_IRQHandler                   /* SPI6                         */
+  .word     SAI1_IRQHandler                   /* SAI1                         */
+  .word     LTDC_IRQHandler                   /* LTDC                         */
+  .word     LTDC_ER_IRQHandler                /* LTDC error                   */
+  .word     DMA2D_IRQHandler                  /* DMA2D                        */
+  .word     SAI2_IRQHandler                   /* SAI2                         */
+  .word     QUADSPI_IRQHandler                /* QUADSPI                      */
+  .word     LPTIM1_IRQHandler                 /* LPTIM1                       */
+  .word     CEC_IRQHandler                    /* HDMI_CEC                     */
+  .word     I2C4_EV_IRQHandler                /* I2C4 Event                   */
+  .word     I2C4_ER_IRQHandler                /* I2C4 Error                   */
+  .word     SPDIF_RX_IRQHandler               /* SPDIF_RX                     */ 
+  .word     OTG_FS_EP1_OUT_IRQHandler         /* USB OTG FS End Point 1 Out   */   
+  .word     OTG_FS_EP1_IN_IRQHandler          /* USB OTG FS End Point 1 In    */   
+  .word     OTG_FS_WKUP_IRQHandler            /* USB OTG FS Wakeup through EXTI */  
+  .word     OTG_FS_IRQHandler                 /* USB OTG FS                   */
+  .word     DMAMUX1_OVR_IRQHandler            /* DMAMUX1 Overrun interrupt    */  
+  .word     HRTIM1_Master_IRQHandler          /* HRTIM Master Timer global Interrupt */
+  .word     HRTIM1_TIMA_IRQHandler            /* HRTIM Timer A global Interrupt */  
+  .word     HRTIM1_TIMB_IRQHandler            /* HRTIM Timer B global Interrupt */  
+  .word     HRTIM1_TIMC_IRQHandler            /* HRTIM Timer C global Interrupt */  
+  .word     HRTIM1_TIMD_IRQHandler            /* HRTIM Timer D global Interrupt */  
+  .word     HRTIM1_TIME_IRQHandler            /* HRTIM Timer E global Interrupt */  
+  .word     HRTIM1_FLT_IRQHandler             /* HRTIM Fault global Interrupt   */ 
+  .word     DFSDM1_FLT0_IRQHandler            /* DFSDM Filter0 Interrupt        */
+  .word     DFSDM1_FLT1_IRQHandler            /* DFSDM Filter1 Interrupt        */     
+  .word     DFSDM1_FLT2_IRQHandler            /* DFSDM Filter2 Interrupt        */    
+  .word     DFSDM1_FLT3_IRQHandler            /* DFSDM Filter3 Interrupt        */   
+  .word     SAI3_IRQHandler                   /* SAI3 global Interrupt          */   
+  .word     SWPMI1_IRQHandler                 /* Serial Wire Interface 1 global interrupt */
+  .word     TIM15_IRQHandler                  /* TIM15 global Interrupt      */        
+  .word     TIM16_IRQHandler                  /* TIM16 global Interrupt      */      
+  .word     TIM17_IRQHandler                  /* TIM17 global Interrupt      */      
+  .word     MDIOS_WKUP_IRQHandler             /* MDIOS Wakeup  Interrupt     */     
+  .word     MDIOS_IRQHandler                  /* MDIOS global Interrupt      */    
+  .word     JPEG_IRQHandler                   /* JPEG global Interrupt       */    
+  .word     MDMA_IRQHandler                   /* MDMA global Interrupt       */    
+  .word     DSI_IRQHandler                    /* DSI global Interrupt        */    
+  .word     SDMMC2_IRQHandler                 /* SDMMC2 global Interrupt     */    
+  .word     HSEM1_IRQHandler                  /* HSEM1 global Interrupt      */    
+  .word     HSEM2_IRQHandler                  /* HSEM2 global Interrupt      */    
+  .word     ADC3_IRQHandler                   /* ADC3 global Interrupt       */    
+  .word     DMAMUX2_OVR_IRQHandler            /* DMAMUX Overrun interrupt    */    
+  .word     BDMA_Channel0_IRQHandler          /* BDMA Channel 0 global Interrupt */
+  .word     BDMA_Channel1_IRQHandler          /* BDMA Channel 1 global Interrupt */ 
+  .word     BDMA_Channel2_IRQHandler          /* BDMA Channel 2 global Interrupt */ 
+  .word     BDMA_Channel3_IRQHandler          /* BDMA Channel 3 global Interrupt */ 
+  .word     BDMA_Channel4_IRQHandler          /* BDMA Channel 4 global Interrupt */ 
+  .word     BDMA_Channel5_IRQHandler          /* BDMA Channel 5 global Interrupt */ 
+  .word     BDMA_Channel6_IRQHandler          /* BDMA Channel 6 global Interrupt */ 
+  .word     BDMA_Channel7_IRQHandler          /* BDMA Channel 7 global Interrupt */ 
+  .word     COMP1_IRQHandler                  /* COMP1 global Interrupt     */          
+  .word     LPTIM2_IRQHandler                 /* LP TIM2 global interrupt   */      
+  .word     LPTIM3_IRQHandler                 /* LP TIM3 global interrupt   */     
+  .word     LPTIM4_IRQHandler                 /* LP TIM4 global interrupt   */     
+  .word     LPTIM5_IRQHandler                 /* LP TIM5 global interrupt   */     
+  .word     LPUART1_IRQHandler                /* LP UART1 interrupt         */     
+  .word     WWDG_RST_IRQHandler               /* Window Watchdog reset interrupt (exti_d2_wwdg_it, exti_d1_wwdg_it)*/     
+  .word     CRS_IRQHandler                    /* Clock Recovery Global Interrupt */ 
+  .word     ECC_IRQHandler                    /* ECC diagnostic Global Interrupt */     
+  .word     SAI4_IRQHandler                   /* SAI4 global interrupt      */      
+  .word     0                                 /* Reserved                   */      
+  .word     HOLD_CORE_IRQHandler              /* Hold core interrupt        */      
+  .word     WAKEUP_PIN_IRQHandler             /* Interrupt for all 6 wake-up pins */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler. 
+* As they are weak aliases, any function with the same name will override 
+* this definition.
+* 
+*******************************************************************************/
+   .weak      NMI_Handler
+   .thumb_set NMI_Handler,Default_Handler
+  
+   .weak      HardFault_Handler
+   .thumb_set HardFault_Handler,Default_Handler
+  
+   .weak      MemManage_Handler
+   .thumb_set MemManage_Handler,Default_Handler
+  
+   .weak      BusFault_Handler
+   .thumb_set BusFault_Handler,Default_Handler
+
+   .weak      UsageFault_Handler
+   .thumb_set UsageFault_Handler,Default_Handler
+
+   .weak      SVC_Handler
+   .thumb_set SVC_Handler,Default_Handler
+
+   .weak      DebugMon_Handler
+   .thumb_set DebugMon_Handler,Default_Handler
+
+   .weak      PendSV_Handler
+   .thumb_set PendSV_Handler,Default_Handler
+
+   .weak      SysTick_Handler
+   .thumb_set SysTick_Handler,Default_Handler              
+  
+   .weak      WWDG_IRQHandler                   
+   .thumb_set WWDG_IRQHandler,Default_Handler      
+                  
+   .weak      PVD_AVD_IRQHandler      
+   .thumb_set PVD_AVD_IRQHandler,Default_Handler
+               
+   .weak      TAMP_STAMP_IRQHandler            
+   .thumb_set TAMP_STAMP_IRQHandler,Default_Handler
+            
+   .weak      RTC_WKUP_IRQHandler                  
+   .thumb_set RTC_WKUP_IRQHandler,Default_Handler
+            
+   .weak      FLASH_IRQHandler         
+   .thumb_set FLASH_IRQHandler,Default_Handler
+                  
+   .weak      RCC_IRQHandler      
+   .thumb_set RCC_IRQHandler,Default_Handler
+                  
+   .weak      EXTI0_IRQHandler         
+   .thumb_set EXTI0_IRQHandler,Default_Handler
+                  
+   .weak      EXTI1_IRQHandler         
+   .thumb_set EXTI1_IRQHandler,Default_Handler
+                     
+   .weak      EXTI2_IRQHandler         
+   .thumb_set EXTI2_IRQHandler,Default_Handler 
+                 
+   .weak      EXTI3_IRQHandler         
+   .thumb_set EXTI3_IRQHandler,Default_Handler
+                        
+   .weak      EXTI4_IRQHandler         
+   .thumb_set EXTI4_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream0_IRQHandler               
+   .thumb_set DMA1_Stream0_IRQHandler,Default_Handler
+         
+   .weak      DMA1_Stream1_IRQHandler               
+   .thumb_set DMA1_Stream1_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream2_IRQHandler               
+   .thumb_set DMA1_Stream2_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream3_IRQHandler               
+   .thumb_set DMA1_Stream3_IRQHandler,Default_Handler 
+                 
+   .weak      DMA1_Stream4_IRQHandler              
+   .thumb_set DMA1_Stream4_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream5_IRQHandler               
+   .thumb_set DMA1_Stream5_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream6_IRQHandler               
+   .thumb_set DMA1_Stream6_IRQHandler,Default_Handler
+                  
+   .weak      ADC_IRQHandler      
+   .thumb_set ADC_IRQHandler,Default_Handler
+               
+   .weak      FDCAN1_IT0_IRQHandler   
+   .thumb_set FDCAN1_IT0_IRQHandler,Default_Handler
+            
+   .weak      FDCAN2_IT0_IRQHandler                  
+   .thumb_set FDCAN2_IT0_IRQHandler,Default_Handler
+                           
+   .weak      FDCAN1_IT1_IRQHandler                  
+   .thumb_set FDCAN1_IT1_IRQHandler,Default_Handler
+            
+   .weak      FDCAN2_IT1_IRQHandler                  
+   .thumb_set FDCAN2_IT1_IRQHandler,Default_Handler
+            
+   .weak      EXTI9_5_IRQHandler   
+   .thumb_set EXTI9_5_IRQHandler,Default_Handler
+            
+   .weak      TIM1_BRK_IRQHandler            
+   .thumb_set TIM1_BRK_IRQHandler,Default_Handler
+            
+   .weak      TIM1_UP_IRQHandler            
+   .thumb_set TIM1_UP_IRQHandler,Default_Handler
+
+   .weak      TIM1_TRG_COM_IRQHandler      
+   .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler
+      
+   .weak      TIM1_CC_IRQHandler   
+   .thumb_set TIM1_CC_IRQHandler,Default_Handler
+                  
+   .weak      TIM2_IRQHandler            
+   .thumb_set TIM2_IRQHandler,Default_Handler
+                  
+   .weak      TIM3_IRQHandler            
+   .thumb_set TIM3_IRQHandler,Default_Handler
+                  
+   .weak      TIM4_IRQHandler            
+   .thumb_set TIM4_IRQHandler,Default_Handler
+                  
+   .weak      I2C1_EV_IRQHandler   
+   .thumb_set I2C1_EV_IRQHandler,Default_Handler
+                     
+   .weak      I2C1_ER_IRQHandler   
+   .thumb_set I2C1_ER_IRQHandler,Default_Handler
+                     
+   .weak      I2C2_EV_IRQHandler   
+   .thumb_set I2C2_EV_IRQHandler,Default_Handler
+                  
+   .weak      I2C2_ER_IRQHandler   
+   .thumb_set I2C2_ER_IRQHandler,Default_Handler
+                           
+   .weak      SPI1_IRQHandler            
+   .thumb_set SPI1_IRQHandler,Default_Handler
+                        
+   .weak      SPI2_IRQHandler            
+   .thumb_set SPI2_IRQHandler,Default_Handler
+                  
+   .weak      USART1_IRQHandler      
+   .thumb_set USART1_IRQHandler,Default_Handler
+                     
+   .weak      USART2_IRQHandler      
+   .thumb_set USART2_IRQHandler,Default_Handler
+                     
+   .weak      USART3_IRQHandler      
+   .thumb_set USART3_IRQHandler,Default_Handler
+                  
+   .weak      EXTI15_10_IRQHandler               
+   .thumb_set EXTI15_10_IRQHandler,Default_Handler
+               
+   .weak      RTC_Alarm_IRQHandler               
+   .thumb_set RTC_Alarm_IRQHandler,Default_Handler
+            
+   .weak      TIM8_BRK_TIM12_IRQHandler         
+   .thumb_set TIM8_BRK_TIM12_IRQHandler,Default_Handler
+         
+   .weak      TIM8_UP_TIM13_IRQHandler            
+   .thumb_set TIM8_UP_TIM13_IRQHandler,Default_Handler
+         
+   .weak      TIM8_TRG_COM_TIM14_IRQHandler      
+   .thumb_set TIM8_TRG_COM_TIM14_IRQHandler,Default_Handler
+      
+   .weak      TIM8_CC_IRQHandler   
+   .thumb_set TIM8_CC_IRQHandler,Default_Handler
+                  
+   .weak      DMA1_Stream7_IRQHandler               
+   .thumb_set DMA1_Stream7_IRQHandler,Default_Handler
+                     
+   .weak      FMC_IRQHandler            
+   .thumb_set FMC_IRQHandler,Default_Handler
+                     
+   .weak      SDMMC1_IRQHandler            
+   .thumb_set SDMMC1_IRQHandler,Default_Handler
+                     
+   .weak      TIM5_IRQHandler            
+   .thumb_set TIM5_IRQHandler,Default_Handler
+                     
+   .weak      SPI3_IRQHandler            
+   .thumb_set SPI3_IRQHandler,Default_Handler
+                     
+   .weak      UART4_IRQHandler         
+   .thumb_set UART4_IRQHandler,Default_Handler
+                  
+   .weak      UART5_IRQHandler         
+   .thumb_set UART5_IRQHandler,Default_Handler
+                  
+   .weak      TIM6_DAC_IRQHandler                  
+   .thumb_set TIM6_DAC_IRQHandler,Default_Handler
+               
+   .weak      TIM7_IRQHandler            
+   .thumb_set TIM7_IRQHandler,Default_Handler
+         
+   .weak      DMA2_Stream0_IRQHandler               
+   .thumb_set DMA2_Stream0_IRQHandler,Default_Handler
+               
+   .weak      DMA2_Stream1_IRQHandler               
+   .thumb_set DMA2_Stream1_IRQHandler,Default_Handler
+                  
+   .weak      DMA2_Stream2_IRQHandler               
+   .thumb_set DMA2_Stream2_IRQHandler,Default_Handler
+            
+   .weak      DMA2_Stream3_IRQHandler               
+   .thumb_set DMA2_Stream3_IRQHandler,Default_Handler
+            
+   .weak      DMA2_Stream4_IRQHandler               
+   .thumb_set DMA2_Stream4_IRQHandler,Default_Handler
+    
+   .weak      ETH_IRQHandler   
+   .thumb_set ETH_IRQHandler,Default_Handler
+   
+   .weak      ETH_WKUP_IRQHandler   
+   .thumb_set ETH_WKUP_IRQHandler,Default_Handler
+
+   .weak      FDCAN_CAL_IRQHandler   
+   .thumb_set FDCAN_CAL_IRQHandler,Default_Handler   
+
+   .weak      CM7_SEV_IRQHandler   
+   .thumb_set CM7_SEV_IRQHandler,Default_Handler   
+
+   .weak      CM4_SEV_IRQHandler   
+   .thumb_set CM4_SEV_IRQHandler,Default_Handler   
+                                                                  
+   .weak      DMA2_Stream5_IRQHandler               
+   .thumb_set DMA2_Stream5_IRQHandler,Default_Handler
+                  
+   .weak      DMA2_Stream6_IRQHandler               
+   .thumb_set DMA2_Stream6_IRQHandler,Default_Handler
+                  
+   .weak      DMA2_Stream7_IRQHandler               
+   .thumb_set DMA2_Stream7_IRQHandler,Default_Handler
+                  
+   .weak      USART6_IRQHandler      
+   .thumb_set USART6_IRQHandler,Default_Handler
+                        
+   .weak      I2C3_EV_IRQHandler   
+   .thumb_set I2C3_EV_IRQHandler,Default_Handler
+                        
+   .weak      I2C3_ER_IRQHandler   
+   .thumb_set I2C3_ER_IRQHandler,Default_Handler
+                        
+   .weak      OTG_HS_EP1_OUT_IRQHandler         
+   .thumb_set OTG_HS_EP1_OUT_IRQHandler,Default_Handler
+               
+   .weak      OTG_HS_EP1_IN_IRQHandler            
+   .thumb_set OTG_HS_EP1_IN_IRQHandler,Default_Handler
+               
+   .weak      OTG_HS_WKUP_IRQHandler         
+   .thumb_set OTG_HS_WKUP_IRQHandler,Default_Handler
+            
+   .weak      OTG_HS_IRQHandler      
+   .thumb_set OTG_HS_IRQHandler,Default_Handler
+                  
+   .weak      DCMI_IRQHandler            
+   .thumb_set DCMI_IRQHandler,Default_Handler
+
+   .weak      RNG_IRQHandler            
+   .thumb_set RNG_IRQHandler,Default_Handler   
+
+   .weak      FPU_IRQHandler                  
+   .thumb_set FPU_IRQHandler,Default_Handler
+
+   .weak      UART7_IRQHandler                  
+   .thumb_set UART7_IRQHandler,Default_Handler
+
+   .weak      UART8_IRQHandler                  
+   .thumb_set UART8_IRQHandler,Default_Handler   
+
+   .weak      SPI4_IRQHandler            
+   .thumb_set SPI4_IRQHandler,Default_Handler
+   
+   .weak      SPI5_IRQHandler            
+   .thumb_set SPI5_IRQHandler,Default_Handler
+
+   .weak      SPI6_IRQHandler            
+   .thumb_set SPI6_IRQHandler,Default_Handler   
+
+   .weak      SAI1_IRQHandler            
+   .thumb_set SAI1_IRQHandler,Default_Handler
+   
+   .weak      LTDC_IRQHandler            
+   .thumb_set LTDC_IRQHandler,Default_Handler
+
+   .weak      LTDC_ER_IRQHandler            
+   .thumb_set LTDC_ER_IRQHandler,Default_Handler
+
+   .weak      DMA2D_IRQHandler            
+   .thumb_set DMA2D_IRQHandler,Default_Handler   
+
+   .weak      SAI2_IRQHandler            
+   .thumb_set SAI2_IRQHandler,Default_Handler
+   
+   .weak      QUADSPI_IRQHandler            
+   .thumb_set QUADSPI_IRQHandler,Default_Handler
+ 
+   .weak      LPTIM1_IRQHandler            
+   .thumb_set LPTIM1_IRQHandler,Default_Handler
+
+   .weak      CEC_IRQHandler            
+   .thumb_set CEC_IRQHandler,Default_Handler
+   
+   .weak      I2C4_EV_IRQHandler            
+   .thumb_set I2C4_EV_IRQHandler,Default_Handler 
+ 
+   .weak      I2C4_ER_IRQHandler            
+   .thumb_set I2C4_ER_IRQHandler,Default_Handler
+   
+   .weak      SPDIF_RX_IRQHandler            
+   .thumb_set SPDIF_RX_IRQHandler,Default_Handler
+
+   .weak      OTG_FS_EP1_OUT_IRQHandler            
+   .thumb_set OTG_FS_EP1_OUT_IRQHandler,Default_Handler
+   
+   .weak      OTG_FS_EP1_IN_IRQHandler            
+   .thumb_set OTG_FS_EP1_IN_IRQHandler,Default_Handler 
+
+   .weak      OTG_FS_WKUP_IRQHandler            
+   .thumb_set OTG_FS_WKUP_IRQHandler,Default_Handler
+
+   .weak      OTG_FS_IRQHandler            
+   .thumb_set OTG_FS_IRQHandler,Default_Handler
+   
+   .weak      DMAMUX1_OVR_IRQHandler            
+   .thumb_set DMAMUX1_OVR_IRQHandler,Default_Handler
+
+   .weak      HRTIM1_Master_IRQHandler            
+   .thumb_set HRTIM1_Master_IRQHandler,Default_Handler
+   
+   .weak      HRTIM1_TIMA_IRQHandler            
+   .thumb_set HRTIM1_TIMA_IRQHandler,Default_Handler
+
+   .weak      HRTIM1_TIMB_IRQHandler            
+   .thumb_set HRTIM1_TIMB_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_TIMC_IRQHandler            
+   .thumb_set HRTIM1_TIMC_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_TIMD_IRQHandler            
+   .thumb_set HRTIM1_TIMD_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_TIME_IRQHandler            
+   .thumb_set HRTIM1_TIME_IRQHandler,Default_Handler 
+
+   .weak      HRTIM1_FLT_IRQHandler            
+   .thumb_set HRTIM1_FLT_IRQHandler,Default_Handler
+
+   .weak      DFSDM1_FLT0_IRQHandler            
+   .thumb_set DFSDM1_FLT0_IRQHandler,Default_Handler  
+
+   .weak      DFSDM1_FLT1_IRQHandler            
+   .thumb_set DFSDM1_FLT1_IRQHandler,Default_Handler 
+
+   .weak      DFSDM1_FLT2_IRQHandler            
+   .thumb_set DFSDM1_FLT2_IRQHandler,Default_Handler 
+
+   .weak      DFSDM1_FLT3_IRQHandler            
+   .thumb_set DFSDM1_FLT3_IRQHandler,Default_Handler    
+ 
+   .weak      SAI3_IRQHandler            
+   .thumb_set SAI3_IRQHandler,Default_Handler
+   
+   .weak      SWPMI1_IRQHandler            
+   .thumb_set SWPMI1_IRQHandler,Default_Handler
+
+   .weak      TIM15_IRQHandler            
+   .thumb_set TIM15_IRQHandler,Default_Handler 
+
+   .weak      TIM16_IRQHandler            
+   .thumb_set TIM16_IRQHandler,Default_Handler 
+
+   .weak      TIM17_IRQHandler            
+   .thumb_set TIM17_IRQHandler,Default_Handler 
+
+   .weak      MDIOS_WKUP_IRQHandler            
+   .thumb_set MDIOS_WKUP_IRQHandler,Default_Handler 
+
+   .weak      MDIOS_IRQHandler            
+   .thumb_set MDIOS_IRQHandler,Default_Handler 
+
+   .weak      JPEG_IRQHandler            
+   .thumb_set JPEG_IRQHandler,Default_Handler 
+
+   .weak      MDMA_IRQHandler            
+   .thumb_set MDMA_IRQHandler,Default_Handler 
+
+   .weak      DSI_IRQHandler            
+   .thumb_set DSI_IRQHandler,Default_Handler 
+
+   .weak      SDMMC2_IRQHandler            
+   .thumb_set SDMMC2_IRQHandler,Default_Handler 
+   
+   .weak      HSEM1_IRQHandler            
+   .thumb_set HSEM1_IRQHandler,Default_Handler
+
+   .weak      HSEM2_IRQHandler            
+   .thumb_set HSEM2_IRQHandler,Default_Handler
+
+   .weak      ADC3_IRQHandler            
+   .thumb_set ADC3_IRQHandler,Default_Handler 
+
+   .weak      DMAMUX2_OVR_IRQHandler            
+   .thumb_set DMAMUX2_OVR_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel0_IRQHandler            
+   .thumb_set BDMA_Channel0_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel1_IRQHandler            
+   .thumb_set BDMA_Channel1_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel2_IRQHandler            
+   .thumb_set BDMA_Channel2_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel3_IRQHandler            
+   .thumb_set BDMA_Channel3_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel4_IRQHandler            
+   .thumb_set BDMA_Channel4_IRQHandler,Default_Handler 
+
+   .weak      BDMA_Channel5_IRQHandler            
+   .thumb_set BDMA_Channel5_IRQHandler,Default_Handler    
+
+   .weak      BDMA_Channel6_IRQHandler            
+   .thumb_set BDMA_Channel6_IRQHandler,Default_Handler
+
+   .weak      BDMA_Channel7_IRQHandler            
+   .thumb_set BDMA_Channel7_IRQHandler,Default_Handler 
+
+   .weak      COMP1_IRQHandler            
+   .thumb_set COMP1_IRQHandler,Default_Handler 
+
+   .weak      LPTIM2_IRQHandler            
+   .thumb_set LPTIM2_IRQHandler,Default_Handler 
+
+   .weak      LPTIM3_IRQHandler            
+   .thumb_set LPTIM3_IRQHandler,Default_Handler 
+
+   .weak      LPTIM4_IRQHandler            
+   .thumb_set LPTIM4_IRQHandler,Default_Handler 
+
+   .weak      LPTIM5_IRQHandler            
+   .thumb_set LPTIM5_IRQHandler,Default_Handler 
+
+   .weak      LPUART1_IRQHandler            
+   .thumb_set LPUART1_IRQHandler,Default_Handler 
+
+   .weak      WWDG_RST_IRQHandler            
+   .thumb_set WWDG_RST_IRQHandler,Default_Handler 
+
+   .weak      CRS_IRQHandler            
+   .thumb_set CRS_IRQHandler,Default_Handler 
+
+   .weak      ECC_IRQHandler            
+   .thumb_set ECC_IRQHandler,Default_Handler
+
+   .weak      SAI4_IRQHandler            
+   .thumb_set SAI4_IRQHandler,Default_Handler 
+
+   .weak      HOLD_CORE_IRQHandler            
+   .thumb_set HOLD_CORE_IRQHandler,Default_Handler 
+
+   .weak      WAKEUP_PIN_IRQHandler            
+   .thumb_set WAKEUP_PIN_IRQHandler,Default_Handler 
+   
+/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/        
+ 
diff --git a/targets/TARGET_STM/TARGET_STM32H7/objects.h b/targets/TARGET_STM/TARGET_STM32H7/objects.h
index 39d4d67515..77a0566596 100644
--- a/targets/TARGET_STM/TARGET_STM32H7/objects.h
+++ b/targets/TARGET_STM/TARGET_STM32H7/objects.h
@@ -37,6 +37,7 @@
 #include "stm32h7xx_ll_usart.h"
 #include "stm32h7xx_ll_rtc.h"
 #include "stm32h7xx_ll_tim.h"
+#include "stm32h7xx_hal_qspi.h"
 #if defined(DUAL_CORE)
 #include "stm32h7xx_ll_hsem.h"
 #include "stm32h7xx_ll_rcc.h"
diff --git a/targets/TARGET_STM/USBPhy_STM32.cpp b/targets/TARGET_STM/USBPhy_STM32.cpp
index f748dcd9a3..d7dd337093 100644
--- a/targets/TARGET_STM/USBPhy_STM32.cpp
+++ b/targets/TARGET_STM/USBPhy_STM32.cpp
@@ -204,6 +204,8 @@ void USBPhyHw::init(USBPhyEvents *events)
     hpcd.Init.speed = PCD_SPEED_HIGH;
     __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
     __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
+    __HAL_RCC_USB_OTG_HS_CLK_SLEEP_ENABLE();
+    __HAL_RCC_USB_OTG_HS_ULPI_CLK_SLEEP_ENABLE();
     map = PinMap_USB_HS;
 #elif (MBED_CONF_TARGET_USB_SPEED == USE_USB_OTG_HS)
     hpcd.Instance = USB_OTG_HS;
@@ -237,7 +239,9 @@ void USBPhyHw::init(USBPhyEvents *events)
         map++;
     }
 
+#if !defined(TARGET_STM32H7)
     __HAL_RCC_PWR_CLK_ENABLE();
+#endif
 
 #if !defined(TARGET_STM32WB)
     __HAL_RCC_SYSCFG_CLK_ENABLE();
diff --git a/targets/targets.json b/targets/targets.json
index d85b09d2ff..fe4382bf40 100644
--- a/targets/targets.json
+++ b/targets/targets.json
@@ -2675,6 +2675,98 @@
             "network-default-interface-type": "ETHERNET"
         }
     },
+    "PORTENTA_H7": {
+        "core": "",
+        "public": false,
+        "inherits": ["MCU_STM32"],
+        "extra_labels_add": [
+            "STM32H7",
+            "STM32H747xI",
+            "STM_EMAC",
+            "CYW4343X",
+            "CORDIO"
+        ],
+        "config": {
+            "clock_source": {
+                "help": "Mask value : USE_PLL_HSE_EXTC | USE_PLL_HSE_XTAL | USE_PLL_HSI",
+                "value": "USE_PLL_HSE_EXTC",
+                "macro_name": "CLOCK_SOURCE"
+            },
+            "lpticker_lptim": {
+                "help": "This target supports LPTIM. Set value 1 to use LPTIM for LPTICKER, or 0 to use RTC wakeup timer",
+                "value": 1
+            },
+            "hse_value": {
+                "help": "HSE default value is 25MHz in HAL",
+                "value": "27000000",
+                "macro_name": "HSE_VALUE"
+            },
+            "usb_speed": {
+                "help": "USE_USB_OTG_FS or USE_USB_OTG_HS or USE_USB_HS_IN_FS",
+                "value": "USE_USB_OTG_HS"
+            }
+        },
+        "macros_add": [
+            "STM32H747xx",
+            "MBED_TICKLESS",
+            "EXTRA_IDLE_STACK_REQUIRED"
+        ],
+        "overrides": { "lpticker_delay_ticks": 4 },
+        "detect_code": ["0813"],
+        "components_add": ["QSPIF"],
+        "extra_labels_add": [
+            "WICED",
+            "CYW43XXX",
+            "CORDIO"
+        ],
+        "features": ["LWIP", "BLE"],
+        "device_has_add": [
+            "ANALOGOUT",
+            "I2C",
+            "USBDEVICE",
+            "CAN",
+            "CRC",
+            "TRNG",
+            "FLASH",
+            "QSPI"
+        ],
+        "overrides": {
+            "lpticker_delay_ticks": 0,
+            "network-default-interface-type": "ETHERNET"
+        },
+        "release_versions": ["5"],
+        "device_name": "STM32H747XIHx",
+        "bootloader_supported": true
+    },
+    "PORTENTA_H7_M7": {
+        "inherits": ["PORTENTA_H7"],
+        "core": "Cortex-M7FD",
+        "macros_add": [
+            "CORE_CM7"
+        ],
+        "components_add": ["FLASHIAP"],
+        "mbed_rom_start": "0x08000000",
+        "mbed_rom_size" : "0x100000",
+        "mbed_ram_start": "0x24000000",
+        "mbed_ram_size" : "0x80000",
+        "device_has_add": [
+            "MPU",
+            "EMAC"
+        ]
+    },
+    "PORTENTA_H7_M4": {
+        "inherits": ["PORTENTA_H7"],
+        "core": "Cortex-M4F",
+        "components_add": ["FLASHIAP"],
+        "mbed_rom_start": "0x08100000",
+        "mbed_rom_size" : "0x100000",
+        "mbed_ram_start": "0x10000000",
+        "mbed_ram_size" : "0x48000",
+        "macros_add": [
+            "CORE_CM4",
+            "MBED_MPU_CUSTOM"
+        ]
+    },
     "NUCLEO_G071RB": {
         "inherits": [
             "MCU_STM32_BAREMETAL"
-- 
2.27.0

